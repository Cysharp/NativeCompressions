/* automatically generated by rust-bindgen 0.64.0 */

pub const LZ4_HEAPMODE: u32 = 0;
pub const LZ4_ACCELERATION_DEFAULT: u32 = 1;
pub const LZ4_ACCELERATION_MAX: u32 = 65537;
pub const LZ4_SRC_INCLUDED: u32 = 1;
pub const LZ4_FREESTANDING: u32 = 0;
pub const LZ4_VERSION_MAJOR: u32 = 1;
pub const LZ4_VERSION_MINOR: u32 = 9;
pub const LZ4_VERSION_RELEASE: u32 = 4;
pub const LZ4_VERSION_NUMBER: u32 = 10904;
pub const LZ4_MEMORY_USAGE_MIN: u32 = 10;
pub const LZ4_MEMORY_USAGE_DEFAULT: u32 = 14;
pub const LZ4_MEMORY_USAGE_MAX: u32 = 20;
pub const LZ4_MEMORY_USAGE: u32 = 14;
pub const LZ4_MAX_INPUT_SIZE: u32 = 2113929216;
pub const LZ4_DISTANCE_MAX: u32 = 65535;
pub const LZ4_COMPRESS_INPLACE_MARGIN: u32 = 65567;
pub const LZ4_HASHLOG: u32 = 12;
pub const LZ4_HASHTABLESIZE: u32 = 16384;
pub const LZ4_HASH_SIZE_U32: u32 = 4096;
pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const LZ4_STREAM_MINSIZE: u32 = 16416;
pub const LZ4_STREAMDECODE_MINSIZE: u32 = 32;
pub const __FULLBX: &[u8; 4usize] = b"rbx\0";
pub const __TMPGPR: &[u8; 4usize] = b"rax\0";
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const _HEAP_MAXREQ: i32 = -32;
pub const _HEAPEMPTY: i32 = -1;
pub const _HEAPOK: i32 = -2;
pub const _HEAPBADBEGIN: i32 = -3;
pub const _HEAPBADNODE: i32 = -4;
pub const _HEAPEND: i32 = -5;
pub const _HEAPBADPTR: i32 = -6;
pub const _FREEENTRY: u32 = 0;
pub const _USEDENTRY: u32 = 1;
pub const _ALLOCA_S_THRESHOLD: u32 = 1024;
pub const _ALLOCA_S_STACK_MARKER: u32 = 52428;
pub const _ALLOCA_S_HEAP_MARKER: u32 = 56797;
pub const _ALLOCA_S_MARKER_SIZE: u32 = 16;
pub const _MM_HINT_ET0: u32 = 7;
pub const _MM_HINT_ET1: u32 = 6;
pub const _MM_HINT_T0: u32 = 3;
pub const _MM_HINT_T1: u32 = 2;
pub const _MM_HINT_T2: u32 = 1;
pub const _MM_HINT_NTA: u32 = 0;
pub const _MM_EXCEPT_INVALID: u32 = 1;
pub const _MM_EXCEPT_DENORM: u32 = 2;
pub const _MM_EXCEPT_DIV_ZERO: u32 = 4;
pub const _MM_EXCEPT_OVERFLOW: u32 = 8;
pub const _MM_EXCEPT_UNDERFLOW: u32 = 16;
pub const _MM_EXCEPT_INEXACT: u32 = 32;
pub const _MM_EXCEPT_MASK: u32 = 63;
pub const _MM_MASK_INVALID: u32 = 128;
pub const _MM_MASK_DENORM: u32 = 256;
pub const _MM_MASK_DIV_ZERO: u32 = 512;
pub const _MM_MASK_OVERFLOW: u32 = 1024;
pub const _MM_MASK_UNDERFLOW: u32 = 2048;
pub const _MM_MASK_INEXACT: u32 = 4096;
pub const _MM_MASK_MASK: u32 = 8064;
pub const _MM_ROUND_NEAREST: u32 = 0;
pub const _MM_ROUND_DOWN: u32 = 8192;
pub const _MM_ROUND_UP: u32 = 16384;
pub const _MM_ROUND_TOWARD_ZERO: u32 = 24576;
pub const _MM_ROUND_MASK: u32 = 24576;
pub const _MM_FLUSH_ZERO_MASK: u32 = 32768;
pub const _MM_FLUSH_ZERO_ON: u32 = 32768;
pub const _MM_FLUSH_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_ON: u32 = 64;
pub const _MM_DENORMALS_ZERO_OFF: u32 = 0;
pub const _MM_DENORMALS_ZERO_MASK: u32 = 64;
pub const _XCR_XFEATURE_ENABLED_MASK: u32 = 0;
pub const _JBLEN: u32 = 16;
pub const LZ4_ALIGN_TEST: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const EDEADLK: u32 = 36;
pub const ENAMETOOLONG: u32 = 38;
pub const ENOLCK: u32 = 39;
pub const ENOSYS: u32 = 40;
pub const ENOTEMPTY: u32 = 41;
pub const EINVAL: u32 = 22;
pub const ERANGE: u32 = 34;
pub const EILSEQ: u32 = 42;
pub const STRUNCATE: u32 = 80;
pub const EDEADLOCK: u32 = 36;
pub const EADDRINUSE: u32 = 100;
pub const EADDRNOTAVAIL: u32 = 101;
pub const EAFNOSUPPORT: u32 = 102;
pub const EALREADY: u32 = 103;
pub const EBADMSG: u32 = 104;
pub const ECANCELED: u32 = 105;
pub const ECONNABORTED: u32 = 106;
pub const ECONNREFUSED: u32 = 107;
pub const ECONNRESET: u32 = 108;
pub const EDESTADDRREQ: u32 = 109;
pub const EHOSTUNREACH: u32 = 110;
pub const EIDRM: u32 = 111;
pub const EINPROGRESS: u32 = 112;
pub const EISCONN: u32 = 113;
pub const ELOOP: u32 = 114;
pub const EMSGSIZE: u32 = 115;
pub const ENETDOWN: u32 = 116;
pub const ENETRESET: u32 = 117;
pub const ENETUNREACH: u32 = 118;
pub const ENOBUFS: u32 = 119;
pub const ENODATA: u32 = 120;
pub const ENOLINK: u32 = 121;
pub const ENOMSG: u32 = 122;
pub const ENOPROTOOPT: u32 = 123;
pub const ENOSR: u32 = 124;
pub const ENOSTR: u32 = 125;
pub const ENOTCONN: u32 = 126;
pub const ENOTRECOVERABLE: u32 = 127;
pub const ENOTSOCK: u32 = 128;
pub const ENOTSUP: u32 = 129;
pub const EOPNOTSUPP: u32 = 130;
pub const EOTHER: u32 = 131;
pub const EOVERFLOW: u32 = 132;
pub const EOWNERDEAD: u32 = 133;
pub const EPROTO: u32 = 134;
pub const EPROTONOSUPPORT: u32 = 135;
pub const EPROTOTYPE: u32 = 136;
pub const ETIME: u32 = 137;
pub const ETIMEDOUT: u32 = 138;
pub const ETXTBSY: u32 = 139;
pub const EWOULDBLOCK: u32 = 140;
pub const _NLSCMPERROR: u32 = 2147483647;
pub const MINMATCH: u32 = 4;
pub const WILDCOPYLENGTH: u32 = 8;
pub const LASTLITERALS: u32 = 5;
pub const MFLIMIT: u32 = 12;
pub const MATCH_SAFEGUARD_DISTANCE: u32 = 12;
pub const FASTLOOP_SAFE_DISTANCE: u32 = 64;
pub const LZ4_DISTANCE_ABSOLUTE_MAX: u32 = 65535;
pub const ML_BITS: u32 = 4;
pub const ML_MASK: u32 = 15;
pub const RUN_BITS: u32 = 4;
pub const RUN_MASK: u32 = 15;
pub const LZ4_FAST_DEC_LOOP: u32 = 1;
pub const LZ4HC_HEAPMODE: u32 = 1;
pub const LZ4HC_CLEVEL_MIN: u32 = 3;
pub const LZ4HC_CLEVEL_DEFAULT: u32 = 9;
pub const LZ4HC_CLEVEL_OPT_MIN: u32 = 10;
pub const LZ4HC_CLEVEL_MAX: u32 = 12;
pub const LZ4HC_DICTIONARY_LOGSIZE: u32 = 16;
pub const LZ4HC_MAXD: u32 = 65536;
pub const LZ4HC_MAXD_MASK: u32 = 65535;
pub const LZ4HC_HASH_LOG: u32 = 15;
pub const LZ4HC_HASHTABLESIZE: u32 = 32768;
pub const LZ4HC_HASH_MASK: u32 = 32767;
pub const LZ4_STREAMHC_MINSIZE: u32 = 262200;
pub const LZ4_OPT_NUM: u32 = 4096;
pub const TRAILING_LITERALS: u32 = 3;
pub const LZ4F_HEAPMODE: u32 = 0;
pub const LZ4F_VERSION: u32 = 100;
pub const LZ4F_HEADER_SIZE_MIN: u32 = 7;
pub const LZ4F_HEADER_SIZE_MAX: u32 = 19;
pub const LZ4F_BLOCK_HEADER_SIZE: u32 = 4;
pub const LZ4F_BLOCK_CHECKSUM_SIZE: u32 = 4;
pub const LZ4F_CONTENT_CHECKSUM_SIZE: u32 = 4;
pub const LZ4F_MAGICNUMBER: u32 = 407708164;
pub const LZ4F_MAGIC_SKIPPABLE_START: u32 = 407710288;
pub const LZ4F_MIN_SIZE_TO_KNOW_HEADER_LENGTH: u32 = 5;
pub const XXHASH_H_5627135585666179: u32 = 1;
pub const XXH_VERSION_MAJOR: u32 = 0;
pub const XXH_VERSION_MINOR: u32 = 6;
pub const XXH_VERSION_RELEASE: u32 = 5;
pub const XXH_VERSION_NUMBER: u32 = 605;
pub const _1BIT: u32 = 1;
pub const _2BITS: u32 = 3;
pub const _3BITS: u32 = 7;
pub const _4BITS: u32 = 15;
pub const _8BITS: u32 = 255;
pub const LZ4F_BLOCKUNCOMPRESSED_FLAG: u32 = 2147483648;
pub const XXH_ACCEPT_NULL_INPUT_POINTER: u32 = 0;
pub const XXH_FORCE_NATIVE_FORMAT: u32 = 0;
pub const XXH_FORCE_ALIGN_CHECK: u32 = 0;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;
extern "C" {
    pub fn LZ4_versionNumber() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_versionString() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " LZ4_compress_default() :\n  Compresses 'srcSize' bytes from buffer 'src'\n  into already allocated 'dst' buffer of size 'dstCapacity'.\n  Compression is guaranteed to succeed if 'dstCapacity' >= LZ4_compressBound(srcSize).\n  It also runs faster, so it's a recommended setting.\n  If the function cannot compress 'src' into a more limited 'dst' budget,\n  compression stops *immediately*, and the function result is zero.\n  In which case, 'dst' content is undefined (invalid).\n      srcSize : max supported value is LZ4_MAX_INPUT_SIZE.\n      dstCapacity : size of buffer 'dst' (which must be already allocated)\n     @return  : the number of bytes written into buffer 'dst' (necessarily <= dstCapacity)\n                or 0 if compression fails\n Note : This function is protected against buffer overflow scenarios (never writes outside 'dst' buffer, nor read outside 'source' buffer)."]
    pub fn LZ4_compress_default(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe() :\n  compressedSize : is the exact complete size of the compressed block.\n  dstCapacity : is the size of destination buffer (which must be already allocated), presumed an upper bound of decompressed size.\n @return : the number of bytes decompressed into destination buffer (necessarily <= dstCapacity)\n           If destination buffer is not large enough, decoding will stop and output an error code (negative value).\n           If the source stream is detected malformed, the function will stop decoding and return a negative result.\n Note 1 : This function is protected against malicious data packets :\n          it will never writes outside 'dst' buffer, nor read outside 'source' buffer,\n          even if the compressed block is maliciously modified to order the decoder to do these actions.\n          In such case, the decoder stops immediately, and considers the compressed block malformed.\n Note 2 : compressedSize and dstCapacity must be provided to the function, the compressed block does not contain them.\n          The implementation is free to send / store / derive this information in whichever way is most beneficial.\n          If there is a need for a different format which bundles together both compressed data and its metadata, consider looking at lz4frame.h instead."]
    pub fn LZ4_decompress_safe(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compressBound() :\nProvides the maximum size that LZ4 compression may output in a \"worst case\" scenario (input data not compressible)\nThis function is primarily useful for memory allocation purposes (destination buffer size).\nMacro LZ4_COMPRESSBOUND() is also provided for compilation-time evaluation (stack memory allocation for example).\nNote that LZ4_compress_default() compresses faster when dstCapacity is >= LZ4_compressBound(srcSize)\ninputSize  : max supported value is LZ4_MAX_INPUT_SIZE\nreturn : maximum output size in a \"worst case\" scenario\nor 0, if input size is incorrect (too large or negative)"]
    pub fn LZ4_compressBound(inputSize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast() :\nSame as LZ4_compress_default(), but allows selection of \"acceleration\" factor.\nThe larger the acceleration value, the faster the algorithm, but also the lesser the compression.\nIt's a trade-off. It can be fine tuned, with each successive value providing roughly +~3% to speed.\nAn acceleration value of \"1\" is the same as regular LZ4_compress_default()\nValues <= 0 will be replaced by LZ4_ACCELERATION_DEFAULT (currently == 1, see lz4.c).\nValues > LZ4_ACCELERATION_MAX will be replaced by LZ4_ACCELERATION_MAX (currently == 65537, see lz4.c)."]
    pub fn LZ4_compress_fast(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_extState() :\n  Same as LZ4_compress_fast(), using an externally allocated memory space for its state.\n  Use LZ4_sizeofState() to know how much memory must be allocated,\n  and allocate it on 8-bytes boundaries (using `malloc()` typically).\n  Then, provide this buffer as `void* state` to compression function."]
    pub fn LZ4_sizeofState() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_fast_extState(
        state: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_destSize() :\n  Reverse the logic : compresses as much data as possible from 'src' buffer\n  into already allocated buffer 'dst', of size >= 'targetDestSize'.\n  This function either compresses the entire 'src' content into 'dst' if it's large enough,\n  or fill 'dst' buffer completely with as much data as possible from 'src'.\n  note: acceleration parameter is fixed to \"default\".\n\n *srcSizePtr : will be modified to indicate how many bytes where read from 'src' to fill 'dst'.\n               New value is necessarily <= input value.\n @return : Nb bytes written into 'dst' (necessarily <= targetDestSize)\n           or 0 if compression fails.\n\n Note : from v1.8.2 to v1.9.1, this function had a bug (fixed un v1.9.2+):\n        the produced compressed content could, in specific circumstances,\n        require to be decompressed into a destination buffer larger\n        by at least 1 byte than the content to decompress.\n        If an application uses `LZ4_compress_destSize()`,\n        it's highly recommended to update liblz4 to v1.9.2 or better.\n        If this can't be done or ensured,\n        the receiving decompression function should provide\n        a dstCapacity which is > decompressedSize, by at least 1 byte.\n        See https://github.com/lz4/lz4/issues/859 for details"]
    pub fn LZ4_compress_destSize(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSizePtr: *mut ::std::os::raw::c_int,
        targetDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_safe_partial() :\n  Decompress an LZ4 compressed block, of size 'srcSize' at position 'src',\n  into destination buffer 'dst' of size 'dstCapacity'.\n  Up to 'targetOutputSize' bytes will be decoded.\n  The function stops decoding on reaching this objective.\n  This can be useful to boost performance\n  whenever only the beginning of a block is required.\n\n @return : the number of bytes decoded in `dst` (necessarily <= targetOutputSize)\n           If source stream is detected malformed, function returns a negative result.\n\n  Note 1 : @return can be < targetOutputSize, if compressed block contains less data.\n\n  Note 2 : targetOutputSize must be <= dstCapacity\n\n  Note 3 : this function effectively stops decoding on reaching targetOutputSize,\n           so dstCapacity is kind of redundant.\n           This is because in older versions of this function,\n           decoding operation would still write complete sequences.\n           Therefore, there was no guarantee that it would stop writing at exactly targetOutputSize,\n           it could write more bytes, though only up to dstCapacity.\n           Some \"margin\" used to be required for this operation to work properly.\n           Thankfully, this is no longer necessary.\n           The function nonetheless keeps the same signature, in an effort to preserve API compatibility.\n\n  Note 4 : If srcSize is the exact size of the block,\n           then targetOutputSize can be any value,\n           including larger than the block's decompressed size.\n           The function will, at most, generate block's decompressed size.\n\n  Note 5 : If srcSize is _larger_ than block's compressed size,\n           then targetOutputSize **MUST** be <= block's decompressed size.\n           Otherwise, *silent corruption will occur*."]
    pub fn LZ4_decompress_safe_partial(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        targetOutputSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_stream_t = LZ4_stream_u;
extern "C" {
    pub fn LZ4_createStream() -> *mut LZ4_stream_t;
}
extern "C" {
    pub fn LZ4_freeStream(streamPtr: *mut LZ4_stream_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream_fast() : v1.9.0+\n  Use this to prepare an LZ4_stream_t for a new chain of dependent blocks\n  (e.g., LZ4_compress_fast_continue()).\n\n  An LZ4_stream_t must be initialized once before usage.\n  This is automatically done when created by LZ4_createStream().\n  However, should the LZ4_stream_t be simply declared on stack (for example),\n  it's necessary to initialize it first, using LZ4_initStream().\n\n  After init, start any new stream with LZ4_resetStream_fast().\n  A same LZ4_stream_t can be re-used multiple times consecutively\n  and compress multiple streams,\n  provided that it starts each new stream with LZ4_resetStream_fast().\n\n  LZ4_resetStream_fast() is much faster than LZ4_initStream(),\n  but is not compatible with memory regions containing garbage data.\n\n  Note: it's only useful to call LZ4_resetStream_fast()\n        in the context of streaming compression.\n        The *extState* functions perform their own resets.\n        Invoking LZ4_resetStream_fast() before is redundant, and even counterproductive."]
    pub fn LZ4_resetStream_fast(streamPtr: *mut LZ4_stream_t);
}
extern "C" {
    #[doc = " LZ4_loadDict() :\n  Use this function to reference a static dictionary into LZ4_stream_t.\n  The dictionary must remain available during compression.\n  LZ4_loadDict() triggers a reset, so any previous data will be forgotten.\n  The same dictionary will have to be loaded on decompression side for successful decoding.\n  Dictionary are useful for better compression of small data (KB range).\n  While LZ4 accept any input as dictionary,\n  results are generally better when using Zstandard's Dictionary Builder.\n  Loading a size of 0 is allowed, and is the same as reset.\n @return : loaded dictionary size, in bytes (necessarily <= 64 KB)"]
    pub fn LZ4_loadDict(
        streamPtr: *mut LZ4_stream_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_continue() :\n  Compress 'src' content using data from previously compressed blocks, for better compression ratio.\n 'dst' buffer must be already allocated.\n  If dstCapacity >= LZ4_compressBound(srcSize), compression is guaranteed to succeed, and runs faster.\n\n @return : size of compressed block\n           or 0 if there is an error (typically, cannot fit into 'dst').\n\n  Note 1 : Each invocation to LZ4_compress_fast_continue() generates a new block.\n           Each block has precise boundaries.\n           Each block must be decompressed separately, calling LZ4_decompress_*() with relevant metadata.\n           It's not possible to append blocks together and expect a single invocation of LZ4_decompress_*() to decompress them together.\n\n  Note 2 : The previous 64KB of source data is __assumed__ to remain present, unmodified, at same address in memory !\n\n  Note 3 : When input is structured as a double-buffer, each buffer can have any size, including < 64 KB.\n           Make sure that buffers are separated, by at least one byte.\n           This construction ensures that each block only depends on previous block.\n\n  Note 4 : If input buffer is a ring-buffer, it can have any size, including < 64 KB.\n\n  Note 5 : After an error, the stream status is undefined (invalid), it can only be reset or freed."]
    pub fn LZ4_compress_fast_continue(
        streamPtr: *mut LZ4_stream_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_saveDict() :\n  If last 64KB data cannot be guaranteed to remain available at its current memory location,\n  save it into a safer place (char* safeBuffer).\n  This is schematically equivalent to a memcpy() followed by LZ4_loadDict(),\n  but is much faster, because LZ4_saveDict() doesn't need to rebuild tables.\n @return : saved dictionary size in bytes (necessarily <= maxDictSize), or 0 if error."]
    pub fn LZ4_saveDict(
        streamPtr: *mut LZ4_stream_t,
        safeBuffer: *mut ::std::os::raw::c_char,
        maxDictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_streamDecode_t = LZ4_streamDecode_u;
extern "C" {
    pub fn LZ4_createStreamDecode() -> *mut LZ4_streamDecode_t;
}
extern "C" {
    pub fn LZ4_freeStreamDecode(LZ4_stream: *mut LZ4_streamDecode_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_setStreamDecode() :\n  An LZ4_streamDecode_t context can be allocated once and re-used multiple times.\n  Use this function to start decompression of a new stream of blocks.\n  A dictionary can optionally be set. Use NULL or size 0 for a reset order.\n  Dictionary is presumed stable : it must remain accessible and unmodified during next decompression.\n @return : 1 if OK, 0 if error"]
    pub fn LZ4_setStreamDecode(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decoderRingBufferSize() : v1.8.2+\n  Note : in a ring buffer scenario (optional),\n  blocks are presumed decompressed next to each other\n  up to the moment there is not enough remaining space for next block (remainingSize < maxBlockSize),\n  at which stage it resumes from beginning of ring buffer.\n  When setting such a ring buffer for streaming decompression,\n  provides the minimum size of this ring buffer\n  to be compatible with any source respecting maxBlockSize condition.\n @return : minimum ring buffer size,\n           or 0 if there is an error (invalid maxBlockSize)."]
    pub fn LZ4_decoderRingBufferSize(maxBlockSize: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_*_continue() :\n  These decoding functions allow decompression of consecutive blocks in \"streaming\" mode.\n  A block is an unsplittable entity, it must be presented entirely to a decompression function.\n  Decompression functions only accepts one block at a time.\n  The last 64KB of previously decoded data *must* remain available and unmodified at the memory position where they were decoded.\n  If less than 64KB of data has been decoded, all the data must be present.\n\n  Special : if decompression side sets a ring buffer, it must respect one of the following conditions :\n  - Decompression buffer size is _at least_ LZ4_decoderRingBufferSize(maxBlockSize).\n    maxBlockSize is the maximum size of any single block. It can have any value > 16 bytes.\n    In which case, encoding and decoding buffers do not need to be synchronized.\n    Actually, data can be produced by any source compliant with LZ4 format specification, and respecting maxBlockSize.\n  - Synchronized mode :\n    Decompression buffer size is _exactly_ the same as compression buffer size,\n    and follows exactly same update rule (block boundaries at same positions),\n    and decoding function is provided with exact decompressed size of each block (exception for last block of the stream),\n    _then_ decoding & encoding ring buffer can have any size, including small ones ( < 64 KB).\n  - Decompression buffer is larger than encoding buffer, by a minimum of maxBlockSize more bytes.\n    In which case, encoding and decoding buffers do not need to be synchronized,\n    and encoding ring buffer can have any size, including small ones ( < 64 KB).\n\n  Whenever these conditions are not possible,\n  save the last 64KB of decoded data into a safe buffer where it can't be modified during decompression,\n  then indicate where this data is saved using LZ4_setStreamDecode(), before decompressing next block."]
    pub fn LZ4_decompress_safe_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_decompress_*_usingDict() :\n  These decoding functions work the same as\n  a combination of LZ4_setStreamDecode() followed by LZ4_decompress_*_continue()\n  They are stand-alone, and don't need an LZ4_streamDecode_t structure.\n  Dictionary is presumed stable : it must remain accessible and unmodified during decompression.\n  Performance tip : Decompression speed can be substantially increased\n                    when dst == dictStart + dictSize."]
    pub fn LZ4_decompress_safe_usingDict(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_safe_partial_usingDict(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        targetOutputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_fast_extState_fastReset() :\n  A variant of LZ4_compress_fast_extState().\n\n  Using this variant avoids an expensive initialization step.\n  It is only safe to call if the state buffer is known to be correctly initialized already\n  (see above comment on LZ4_resetStream_fast() for a definition of \"correctly initialized\").\n  From a high level, the difference is that\n  this function initializes the provided state with a call to something like LZ4_resetStream_fast()\n  while LZ4_compress_fast_extState() starts with a call to LZ4_resetStream()."]
    pub fn LZ4_compress_fast_extState_fastReset(
        state: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        acceleration: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_attach_dictionary() :\n  This is an experimental API that allows\n  efficient use of a static dictionary many times.\n\n  Rather than re-loading the dictionary buffer into a working context before\n  each compression, or copying a pre-loaded dictionary's LZ4_stream_t into a\n  working LZ4_stream_t, this function introduces a no-copy setup mechanism,\n  in which the working stream references the dictionary stream in-place.\n\n  Several assumptions are made about the state of the dictionary stream.\n  Currently, only streams which have been prepared by LZ4_loadDict() should\n  be expected to work.\n\n  Alternatively, the provided dictionaryStream may be NULL,\n  in which case any existing dictionary stream is unset.\n\n  If a dictionary is provided, it replaces any pre-existing stream history.\n  The dictionary contents are the only history that can be referenced and\n  logically immediately precede the data compressed in the first subsequent\n  compression call.\n\n  The dictionary will only remain attached to the working stream through the\n  first compression call, at the end of which it is cleared. The dictionary\n  stream (and source buffer) must remain in-place / accessible / unchanged\n  through the completion of the first compression call on the stream."]
    pub fn LZ4_attach_dictionary(
        workingStream: *mut LZ4_stream_t,
        dictionaryStream: *const LZ4_stream_t,
    );
}
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type LZ4_i8 = i8;
pub type LZ4_byte = u8;
pub type LZ4_u16 = u16;
pub type LZ4_u32 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_stream_t_internal {
    pub hashTable: [LZ4_u32; 4096usize],
    pub dictionary: *const LZ4_byte,
    pub dictCtx: *const LZ4_stream_t_internal,
    pub currentOffset: LZ4_u32,
    pub tableType: LZ4_u32,
    pub dictSize: LZ4_u32,
}
#[test]
fn bindgen_test_layout_LZ4_stream_t_internal() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4_stream_t_internal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4_stream_t_internal>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_stream_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_t_internal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(hashTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictionary) as usize - ptr as usize },
        16384usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictionary)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictCtx) as usize - ptr as usize },
        16392usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictCtx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currentOffset) as usize - ptr as usize },
        16400usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(currentOffset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tableType) as usize - ptr as usize },
        16404usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(tableType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictSize) as usize - ptr as usize },
        16408usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_t_internal),
            "::",
            stringify!(dictSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_stream_u {
    pub minStateSize: [::std::os::raw::c_char; 16416usize],
    pub internal_donotuse: LZ4_stream_t_internal,
}
#[test]
fn bindgen_test_layout_LZ4_stream_u() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4_stream_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4_stream_u>(),
        16416usize,
        concat!("Size of: ", stringify!(LZ4_stream_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_stream_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_stream_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minStateSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_u),
            "::",
            stringify!(minStateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_donotuse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_stream_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " LZ4_initStream() : v1.9.0+\n  An LZ4_stream_t structure must be initialized at least once.\n  This is automatically done when invoking LZ4_createStream(),\n  but it's not when the structure is simply declared on stack (for example).\n\n  Use LZ4_initStream() to properly initialize a newly declared LZ4_stream_t.\n  It can also initialize any arbitrary buffer of sufficient size,\n  and will @return a pointer of proper type upon initialization.\n\n  Note : initialization fails if size and alignment conditions are not respected.\n         In which case, the function will @return NULL.\n  Note2: An LZ4_stream_t structure guarantees correct alignment and size.\n  Note3: Before v1.9.0, use LZ4_resetStream() instead"]
    pub fn LZ4_initStream(buffer: *mut ::std::os::raw::c_void, size: usize) -> *mut LZ4_stream_t;
}
#[doc = " LZ4_streamDecode_t :\n  Never ever use below internal definitions directly !\n  These definitions are not API/ABI safe, and may change in future versions.\n  If you need static allocation, declare or allocate an LZ4_streamDecode_t object."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4_streamDecode_t_internal {
    pub externalDict: *const LZ4_byte,
    pub prefixEnd: *const LZ4_byte,
    pub extDictSize: usize,
    pub prefixSize: usize,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_t_internal() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4_streamDecode_t_internal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamDecode_t_internal>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamDecode_t_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_t_internal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).externalDict) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(externalDict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixEnd) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixEnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extDictSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(extDictSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_t_internal),
            "::",
            stringify!(prefixSize)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_streamDecode_u {
    pub minStateSize: [::std::os::raw::c_char; 32usize],
    pub internal_donotuse: LZ4_streamDecode_t_internal,
}
#[test]
fn bindgen_test_layout_LZ4_streamDecode_u() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4_streamDecode_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamDecode_u>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4_streamDecode_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamDecode_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamDecode_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minStateSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_u),
            "::",
            stringify!(minStateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_donotuse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamDecode_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    #[doc = " Obsolete compression functions (since v1.7.3)"]
    pub fn LZ4_compress(
        src: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput(
        src: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_withState(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput_withState(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_continue(
        LZ4_streamPtr: *mut LZ4_stream_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_limitedOutput_continue(
        LZ4_streamPtr: *mut LZ4_stream_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obsolete decompression functions (since v1.8.0)"]
    pub fn LZ4_uncompress(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        outputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_uncompress_unknownOutputSize(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        isize_: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_create(inputBuffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn LZ4_sizeofStreamState() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamState(
        state: *mut ::std::os::raw::c_void,
        inputBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_slideInputBuffer(state: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Obsolete streaming decoding functions (since v1.7.0)"]
    pub fn LZ4_decompress_safe_withPrefix64k(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_withPrefix64k(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Obsolete LZ4_decompress_fast variants (since v1.9.0) :\n  These functions used to be faster than LZ4_decompress_safe(),\n  but this is no longer the case. They are now slower.\n  This is because LZ4_decompress_fast() doesn't know the input size,\n  and therefore must progress more cautiously into the input buffer to not read beyond the end of block.\n  On top of that `LZ4_decompress_fast()` is not protected vs malformed or malicious inputs, making it a security liability.\n  As a consequence, LZ4_decompress_fast() is strongly discouraged, and deprecated.\n\n  The last remaining LZ4_decompress_fast() specificity is that\n  it can decompress a block without knowing its compressed size.\n  Such functionality can be achieved in a more secure manner\n  by employing LZ4_decompress_safe_partial().\n\n  Parameters:\n  originalSize : is the uncompressed size to regenerate.\n                 `dst` must be already allocated, its size must be >= 'originalSize' bytes.\n @return : number of bytes read from source buffer (== compressed size).\n           The function expects to finish at block's end exactly.\n           If the source stream is detected malformed, the function stops decoding and returns a negative result.\n  note : LZ4_decompress_fast*() requires originalSize. Thanks to this information, it never writes past the output buffer.\n         However, since it doesn't know its 'src' size, it may read an unknown amount of input, past input buffer bounds.\n         Also, since match offsets are not validated, match reads from 'src' may underflow too.\n         These issues never happen if input (compressed) data is correct.\n         But they may happen if input data is invalid (error or intentional tampering).\n         As a consequence, use these functions in trusted environments with trusted data **only**."]
    pub fn LZ4_decompress_fast(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_continue(
        LZ4_streamDecode: *mut LZ4_streamDecode_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_fast_usingDict(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        originalSize: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStream() :\n  An LZ4_stream_t structure must be initialized at least once.\n  This is done with LZ4_initStream(), or LZ4_resetStream().\n  Consider switching to LZ4_initStream(),\n  invoking LZ4_resetStream() will trigger deprecation warnings in the future."]
    pub fn LZ4_resetStream(streamPtr: *mut LZ4_stream_t);
}
pub type __m64 = [::std::os::raw::c_longlong; 1usize];
pub type __v1di = [::std::os::raw::c_longlong; 1usize];
pub type __v2si = [::std::os::raw::c_int; 2usize];
pub type __v4hi = [::std::os::raw::c_short; 4usize];
pub type __v8qi = [::std::os::raw::c_char; 8usize];
pub type __v4si = [::std::os::raw::c_int; 4usize];
pub type __v4sf = [f32; 4usize];
pub type __m128 = [f32; 4usize];
pub type __m128_u = [f32; 4usize];
pub type __v4su = [::std::os::raw::c_uint; 4usize];
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _heapinfo {
    pub _pentry: *mut ::std::os::raw::c_int,
    pub _size: usize,
    pub _useflag: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__heapinfo() {
    const UNINIT: ::std::mem::MaybeUninit<_heapinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_heapinfo>(),
        24usize,
        concat!("Size of: ", stringify!(_heapinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<_heapinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(_heapinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._pentry) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_pentry)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._useflag) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_heapinfo),
            "::",
            stringify!(_useflag)
        )
    );
}
pub type _HEAPINFO = _heapinfo;
extern "C" {
    pub fn _alloca(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _get_heap_handle() -> isize;
}
extern "C" {
    pub fn _heapmin() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapwalk(_EntryInfo: *mut _HEAPINFO) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _heapchk() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _resetstkoflw() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mm_sfence();
}
extern "C" {
    pub fn _mm_getcsr() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _mm_setcsr(__i: ::std::os::raw::c_uint);
}
pub type __m128d = [f64; 2usize];
pub type __m128i = [::std::os::raw::c_longlong; 2usize];
pub type __m128d_u = [f64; 2usize];
pub type __m128i_u = [::std::os::raw::c_longlong; 2usize];
pub type __v2df = [f64; 2usize];
pub type __v2di = [::std::os::raw::c_longlong; 2usize];
pub type __v8hi = [::std::os::raw::c_short; 8usize];
pub type __v16qi = [::std::os::raw::c_char; 16usize];
pub type __v2du = [::std::os::raw::c_ulonglong; 2usize];
pub type __v8hu = [::std::os::raw::c_ushort; 8usize];
pub type __v16qu = [::std::os::raw::c_uchar; 16usize];
pub type __v16qs = [::std::os::raw::c_schar; 16usize];
extern "C" {
    pub fn _mm_clflush(__p: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn _mm_lfence();
}
extern "C" {
    pub fn _mm_mfence();
}
extern "C" {
    pub fn _mm_pause();
}
extern "C" {
    pub fn _xgetbv(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _xsetbv(arg1: ::std::os::raw::c_uint, arg2: ::std::os::raw::c_ulonglong);
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _SETJMP_FLOAT128 {
    pub Part: [::std::os::raw::c_ulonglong; 2usize],
}
#[test]
fn bindgen_test_layout__SETJMP_FLOAT128() {
    const UNINIT: ::std::mem::MaybeUninit<_SETJMP_FLOAT128> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_SETJMP_FLOAT128>(),
        16usize,
        concat!("Size of: ", stringify!(_SETJMP_FLOAT128))
    );
    assert_eq!(
        ::std::mem::align_of::<_SETJMP_FLOAT128>(),
        16usize,
        concat!("Alignment of ", stringify!(_SETJMP_FLOAT128))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Part) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_SETJMP_FLOAT128),
            "::",
            stringify!(Part)
        )
    );
}
pub type SETJMP_FLOAT128 = _SETJMP_FLOAT128;
pub type _JBTYPE = SETJMP_FLOAT128;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct _JUMP_BUFFER {
    pub Frame: ::std::os::raw::c_ulonglong,
    pub Rbx: ::std::os::raw::c_ulonglong,
    pub Rsp: ::std::os::raw::c_ulonglong,
    pub Rbp: ::std::os::raw::c_ulonglong,
    pub Rsi: ::std::os::raw::c_ulonglong,
    pub Rdi: ::std::os::raw::c_ulonglong,
    pub R12: ::std::os::raw::c_ulonglong,
    pub R13: ::std::os::raw::c_ulonglong,
    pub R14: ::std::os::raw::c_ulonglong,
    pub R15: ::std::os::raw::c_ulonglong,
    pub Rip: ::std::os::raw::c_ulonglong,
    pub MxCsr: ::std::os::raw::c_ulong,
    pub FpCsr: ::std::os::raw::c_ushort,
    pub Spare: ::std::os::raw::c_ushort,
    pub Xmm6: SETJMP_FLOAT128,
    pub Xmm7: SETJMP_FLOAT128,
    pub Xmm8: SETJMP_FLOAT128,
    pub Xmm9: SETJMP_FLOAT128,
    pub Xmm10: SETJMP_FLOAT128,
    pub Xmm11: SETJMP_FLOAT128,
    pub Xmm12: SETJMP_FLOAT128,
    pub Xmm13: SETJMP_FLOAT128,
    pub Xmm14: SETJMP_FLOAT128,
    pub Xmm15: SETJMP_FLOAT128,
}
#[test]
fn bindgen_test_layout__JUMP_BUFFER() {
    const UNINIT: ::std::mem::MaybeUninit<_JUMP_BUFFER> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_JUMP_BUFFER>(),
        256usize,
        concat!("Size of: ", stringify!(_JUMP_BUFFER))
    );
    assert_eq!(
        ::std::mem::align_of::<_JUMP_BUFFER>(),
        16usize,
        concat!("Alignment of ", stringify!(_JUMP_BUFFER))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Frame) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rbx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Rbx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rsp) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Rsp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rbp) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Rbp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rsi) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Rsi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rdi) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Rdi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R12) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(R12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R13) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(R13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R14) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(R14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).R15) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(R15)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Rip) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Rip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).MxCsr) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(MxCsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).FpCsr) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(FpCsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Spare) as usize - ptr as usize },
        94usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Spare)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm6) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Xmm6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm7) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Xmm7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm8) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Xmm8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm9) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Xmm9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm10) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Xmm10)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm11) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Xmm11)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm12) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Xmm12)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm13) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Xmm13)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm14) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Xmm14)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).Xmm15) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(_JUMP_BUFFER),
            "::",
            stringify!(Xmm15)
        )
    );
}
pub type jmp_buf = [_JBTYPE; 16usize];
extern "C" {
    pub fn _setjmp(_Buf: *mut _JBTYPE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn longjmp(_Buf: *mut _JBTYPE, _Value: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _m_from_float(arg1: f32) -> __m64;
}
extern "C" {
    pub fn _m_to_float(arg1: __m64) -> f32;
}
extern "C" {
    pub fn __addfsbyte(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn __addfsdword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __addfsword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn __code_seg(arg1: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __cpuid(arg1: *mut ::std::os::raw::c_int, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __cpuidex(
        arg1: *mut ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn __emul(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __emulu(
        arg1: ::std::os::raw::c_uint,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __getcallerseflags() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __inbyte(arg1: ::std::os::raw::c_ushort) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn __inbytestring(
        arg1: ::std::os::raw::c_ushort,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __incfsbyte(arg1: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __incfsdword(arg1: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __incfsword(arg1: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __indword(arg1: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __indwordstring(
        arg1: ::std::os::raw::c_ushort,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __int2c() -> !;
}
extern "C" {
    pub fn __invlpg(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __inword(arg1: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __inwordstring(
        arg1: ::std::os::raw::c_ushort,
        arg2: *mut ::std::os::raw::c_ushort,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __lidt(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __ll_lshift(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __ll_rshift(
        arg1: ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __nvreg_restore_fence();
}
extern "C" {
    pub fn __nvreg_save_fence();
}
extern "C" {
    pub fn __outbyte(arg1: ::std::os::raw::c_ushort, arg2: ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn __outbytestring(
        arg1: ::std::os::raw::c_ushort,
        arg2: *mut ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __outdword(arg1: ::std::os::raw::c_ushort, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __outdwordstring(
        arg1: ::std::os::raw::c_ushort,
        arg2: *mut ::std::os::raw::c_ulong,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __outword(arg1: ::std::os::raw::c_ushort, arg2: ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn __outwordstring(
        arg1: ::std::os::raw::c_ushort,
        arg2: *mut ::std::os::raw::c_ushort,
        arg3: ::std::os::raw::c_ulong,
    );
}
extern "C" {
    pub fn __readcr0() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __readcr2() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __readcr4() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __readcr8() -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __readdr(arg1: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn __readpmc(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __segmentlimit(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __sidt(arg1: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn __stosb(
        arg1: *mut ::std::os::raw::c_uchar,
        arg2: ::std::os::raw::c_uchar,
        arg3: ::std::os::raw::c_ulonglong,
    );
}
extern "C" {
    pub fn __svm_clgi();
}
extern "C" {
    pub fn __svm_invlpga(arg1: *mut ::std::os::raw::c_void, arg2: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __svm_skinit(arg1: ::std::os::raw::c_int);
}
extern "C" {
    pub fn __svm_stgi();
}
extern "C" {
    pub fn __svm_vmload(arg1: usize);
}
extern "C" {
    pub fn __svm_vmrun(arg1: usize);
}
extern "C" {
    pub fn __svm_vmsave(arg1: usize);
}
extern "C" {
    pub fn __ud2() -> !;
}
extern "C" {
    pub fn __ull_rshift(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __vmx_off();
}
extern "C" {
    pub fn __vmx_vmptrst(arg1: *mut ::std::os::raw::c_ulonglong);
}
extern "C" {
    pub fn __wbinvd();
}
extern "C" {
    pub fn __writecr0(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __writecr4(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __writecr8(arg1: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __writedr(arg1: ::std::os::raw::c_uint, arg2: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn __writefsbyte(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn __writefsdword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __writefsqword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ulonglong);
}
extern "C" {
    pub fn __writefsword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn __writemsr(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ulonglong);
}
extern "C" {
    pub fn _AddressOfReturnAddress() -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _BitScanForward(
        _Index: *mut ::std::os::raw::c_ulong,
        _Mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _BitScanReverse(
        _Index: *mut ::std::os::raw::c_ulong,
        _Mask: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittest(
        arg1: *const ::std::os::raw::c_long,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandcomplement(
        arg1: *mut ::std::os::raw::c_long,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandreset(
        arg1: *mut ::std::os::raw::c_long,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandset(
        arg1: *mut ::std::os::raw::c_long,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _disable();
}
extern "C" {
    pub fn _enable();
}
extern "C" {
    pub fn _InterlockedAddLargeStatistic(
        _Addend: *mut ::std::os::raw::c_longlong,
        _Value: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _interlockedbittestandreset(
        arg1: *mut ::std::os::raw::c_long,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _interlockedbittestandset(
        arg1: *mut ::std::os::raw::c_long,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _InterlockedCompareExchangePointer_HLEAcquire(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _InterlockedCompareExchangePointer_HLERelease(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
        arg3: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _InterlockedExchangeAdd_HLEAcquire(
        arg1: *mut ::std::os::raw::c_long,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedExchangeAdd_HLERelease(
        arg1: *mut ::std::os::raw::c_long,
        arg2: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedExchangeAdd64_HLEAcquire(
        arg1: *mut ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedExchangeAdd64_HLERelease(
        arg1: *mut ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _ReadBarrier();
}
extern "C" {
    pub fn _ReadWriteBarrier();
}
extern "C" {
    pub fn _rorx_u32(
        arg1: ::std::os::raw::c_uint,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _sarx_i32(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _shlx_u32(
        arg1: ::std::os::raw::c_uint,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _shrx_u32(
        arg1: ::std::os::raw::c_uint,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _Store_HLERelease(arg1: *mut ::std::os::raw::c_long, arg2: ::std::os::raw::c_long);
}
extern "C" {
    pub fn _Store64_HLERelease(
        arg1: *mut ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    );
}
extern "C" {
    pub fn _StorePointer_HLERelease(
        arg1: *mut *mut ::std::os::raw::c_void,
        arg2: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn _WriteBarrier();
}
extern "C" {
    pub fn xbegin() -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _xend();
}
extern "C" {
    pub fn __addgsbyte(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn __addgsdword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __addgsqword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ulonglong);
}
extern "C" {
    pub fn __addgsword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn __faststorefence();
}
extern "C" {
    pub fn __incgsbyte(arg1: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __incgsdword(arg1: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __incgsqword(arg1: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __incgsword(arg1: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __readgsbyte(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn __readgsdword(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn __readgsqword(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __readgsword(arg1: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __shiftleft128(
        _LowPart: ::std::os::raw::c_ulonglong,
        _HighPart: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __shiftright128(
        _LowPart: ::std::os::raw::c_ulonglong,
        _HighPart: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __vmx_on(arg1: *mut ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn __vmx_vmclear(arg1: *mut ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn __vmx_vmlaunch() -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn __vmx_vmptrld(arg1: *mut ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn __vmx_vmread(arg1: usize, arg2: *mut usize) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn __vmx_vmresume() -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn __vmx_vmwrite(arg1: usize, arg2: usize) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn __writegsbyte(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_uchar);
}
extern "C" {
    pub fn __writegsdword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn __writegsqword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ulonglong);
}
extern "C" {
    pub fn __writegsword(arg1: ::std::os::raw::c_ulong, arg2: ::std::os::raw::c_ushort);
}
extern "C" {
    pub fn _bittest64(
        arg1: *const ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandcomplement64(
        arg1: *mut ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandreset64(
        arg1: *mut ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _bittestandset64(
        arg1: *mut ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _InterlockedAnd_np(
        _Value: *mut ::std::os::raw::c_long,
        _Mask: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedAnd16_np(
        _Value: *mut ::std::os::raw::c_short,
        _Mask: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _InterlockedAnd64_np(
        _Value: *mut ::std::os::raw::c_longlong,
        _Mask: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedAnd8_np(
        _Value: *mut ::std::os::raw::c_char,
        _Mask: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _interlockedbittestandreset64(
        arg1: *mut ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _interlockedbittestandset64(
        arg1: *mut ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _InterlockedCompareExchange_np(
        _Destination: *mut ::std::os::raw::c_long,
        _Exchange: ::std::os::raw::c_long,
        _Comparand: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedCompareExchange128_np(
        _Destination: *mut ::std::os::raw::c_longlong,
        _ExchangeHigh: ::std::os::raw::c_longlong,
        _ExchangeLow: ::std::os::raw::c_longlong,
        _ComparandResult: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _InterlockedCompareExchange16_np(
        _Destination: *mut ::std::os::raw::c_short,
        _Exchange: ::std::os::raw::c_short,
        _Comparand: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _InterlockedCompareExchange64_np(
        _Destination: *mut ::std::os::raw::c_longlong,
        _Exchange: ::std::os::raw::c_longlong,
        _Comparand: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedCompareExchangePointer_np(
        _Destination: *mut *mut ::std::os::raw::c_void,
        _Exchange: *mut ::std::os::raw::c_void,
        _Comparand: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _InterlockedOr_np(
        _Value: *mut ::std::os::raw::c_long,
        _Mask: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedOr16_np(
        _Value: *mut ::std::os::raw::c_short,
        _Mask: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _InterlockedOr64_np(
        _Value: *mut ::std::os::raw::c_longlong,
        _Mask: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedOr8_np(
        _Value: *mut ::std::os::raw::c_char,
        _Mask: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _InterlockedXor_np(
        _Value: *mut ::std::os::raw::c_long,
        _Mask: ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _InterlockedXor16_np(
        _Value: *mut ::std::os::raw::c_short,
        _Mask: ::std::os::raw::c_short,
    ) -> ::std::os::raw::c_short;
}
extern "C" {
    pub fn _InterlockedXor64_np(
        _Value: *mut ::std::os::raw::c_longlong,
        _Mask: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedXor8_np(
        _Value: *mut ::std::os::raw::c_char,
        _Mask: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_char;
}
extern "C" {
    pub fn _rorx_u64(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _sarx_i64(
        arg1: ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _shlx_u64(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _shrx_u64(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn __mulh(
        arg1: ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __umulh(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _mul128(
        arg1: ::std::os::raw::c_longlong,
        arg2: ::std::os::raw::c_longlong,
        arg3: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _umul128(
        arg1: ::std::os::raw::c_ulonglong,
        arg2: ::std::os::raw::c_ulonglong,
        arg3: *mut ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _BitScanForward64(
        _Index: *mut ::std::os::raw::c_ulong,
        _Mask: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _BitScanReverse64(
        _Index: *mut ::std::os::raw::c_ulong,
        _Mask: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn _InterlockedDecrement64(
        _Addend: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedExchange64(
        _Target: *mut ::std::os::raw::c_longlong,
        _Value: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedExchangeAdd64(
        _Addend: *mut ::std::os::raw::c_longlong,
        _Value: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedExchangeSub64(
        _Subend: *mut ::std::os::raw::c_longlong,
        _Value: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedIncrement64(
        _Addend: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedOr64(
        _Value: *mut ::std::os::raw::c_longlong,
        _Mask: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedXor64(
        _Value: *mut ::std::os::raw::c_longlong,
        _Mask: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedAnd64(
        _Value: *mut ::std::os::raw::c_longlong,
        _Mask: ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _InterlockedCompareExchange128(
        _Destination: *mut ::std::os::raw::c_longlong,
        _ExchangeHigh: ::std::os::raw::c_longlong,
        _ExchangeLow: ::std::os::raw::c_longlong,
        _ComparandResult: *mut ::std::os::raw::c_longlong,
    ) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn memchr(
        _Buf: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        _Dst: *mut ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strchr(
        _Str: *const ::std::os::raw::c_char,
        _Val: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        _Str: *const ::std::os::raw::c_char,
        _Ch: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        _Str: *const ::std::os::raw::c_char,
        _SubStr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn wcschr(
        _Str: *const ::std::os::raw::c_ushort,
        _Ch: ::std::os::raw::c_ushort,
    ) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn wcsrchr(_Str: *const wchar_t, _Ch: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(_Str: *const wchar_t, _SubStr: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _memicmp_l(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memicmp(
        _Buf1: *const ::std::os::raw::c_void,
        _Buf2: *const ::std::os::raw::c_void,
        _Size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcscpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncat_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcsncpy_s(
        _Destination: *mut wchar_t,
        _SizeInWords: rsize_t,
        _Source: *const wchar_t,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstok_s(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscat(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscpy(_Destination: *mut wchar_t, _Source: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcscspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcslen(_String: *const ::std::os::raw::c_ushort) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcsnlen(_Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn wcsncat(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsncmp(
        _String1: *const ::std::os::raw::c_ushort,
        _String2: *const ::std::os::raw::c_ushort,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncpy(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _Count: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcspbrk(_String: *const wchar_t, _Control: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsspn(_String: *const wchar_t, _Control: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcstok(
        _String: *mut wchar_t,
        _Delimiter: *const wchar_t,
        _Context: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror(_ErrorNumber: ::std::os::raw::c_int) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn __wcserror(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn __wcserror_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _ErrorMessage: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicmp_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnset_s(
        _Destination: *mut wchar_t,
        _SizeInWords: usize,
        _Value: wchar_t,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsset_s(_Destination: *mut wchar_t, _SizeInWords: usize, _Value: wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s(_String: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcslwr_s_l(_String: *mut wchar_t, _SizeInWords: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcslwr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s(_String: *mut wchar_t, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wcsupr_s_l(_String: *mut wchar_t, _Size: usize, _Locale: _locale_t) -> errno_t;
}
extern "C" {
    pub fn _wcsupr_l(_String: *mut wchar_t, _Locale: _locale_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsxfrm(_Destination: *mut wchar_t, _Source: *const wchar_t, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _wcsxfrm_l(
        _Destination: *mut wchar_t,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wcscoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcscoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsncoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wcsnicoll_l(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsdup(_String: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicmp(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnicmp(
        _String1: *const wchar_t,
        _String2: *const wchar_t,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsnset(_String: *mut wchar_t, _Value: wchar_t, _MaxCount: usize) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsrev(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsset(_String: *mut wchar_t, _Value: wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcslwr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsupr(_String: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsicoll(_String1: *const wchar_t, _String2: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strcat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorNumber: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn strncat_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strncpy_s(
        _Destination: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: rsize_t,
    ) -> errno_t;
}
extern "C" {
    pub fn strtok_s(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
        _Context: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _memccpy(
        _Dst: *mut ::std::os::raw::c_void,
        _Src: *const ::std::os::raw::c_void,
        _Val: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strcoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strdup(_Source: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror(_ErrorMessage: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strerror_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _ErrorMessage: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn strerror(_ErrorMessage: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _stricmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlen(_Str: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strlwr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strlwr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strlwr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncmp(
        _Str1: *const ::std::os::raw::c_char,
        _Str2: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicmp_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strnicoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _strncoll_l(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __strncnt(_String: *const ::std::os::raw::c_char, _Count: usize) -> usize;
}
extern "C" {
    pub fn strncpy(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _Count: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _strnset_s(
        _String: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _strnset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _Count: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strpbrk(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strrev(_Str: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strset_s(
        _Destination: *mut ::std::os::raw::c_char,
        _DestinationSize: usize,
        _Value: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _strset(
        _Destination: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strspn(
        _Str: *const ::std::os::raw::c_char,
        _Control: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtok(
        _String: *mut ::std::os::raw::c_char,
        _Delimiter: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s(_String: *mut ::std::os::raw::c_char, _Size: usize) -> errno_t;
}
extern "C" {
    pub fn _strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strupr_s_l(
        _String: *mut ::std::os::raw::c_char,
        _Size: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _strupr_l(
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strxfrm(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: ::std::os::raw::c_ulonglong,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strxfrm_l(
        _Destination: *mut ::std::os::raw::c_char,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(_String: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmpi(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stricmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strlwr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strnicmp(
        _String1: *const ::std::os::raw::c_char,
        _String2: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strnset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
        _MaxCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrev(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strset(
        _String: *mut ::std::os::raw::c_char,
        _Value: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strupr(_String: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
pub const LZ4_minLength: ::std::os::raw::c_int = 13;
pub type BYTE = u8;
pub type U16 = u16;
pub type U32 = u32;
pub type S32 = i32;
pub type U64 = u64;
pub type uptrval = usize;
pub type reg_t = U64;
pub const limitedOutput_directive_notLimited: limitedOutput_directive = 0;
pub const limitedOutput_directive_limitedOutput: limitedOutput_directive = 1;
pub const limitedOutput_directive_fillOutput: limitedOutput_directive = 2;
pub type limitedOutput_directive = ::std::os::raw::c_int;
extern "C" {
    pub static inc32table: [::std::os::raw::c_uint; 8usize];
}
extern "C" {
    pub static dec64table: [::std::os::raw::c_int; 8usize];
}
pub const LZ4_64Klimit: ::std::os::raw::c_int = 65547;
pub const LZ4_skipTrigger: U32 = 6;
pub const tableType_t_clearedTable: tableType_t = 0;
pub const tableType_t_byPtr: tableType_t = 1;
pub const tableType_t_byU32: tableType_t = 2;
pub const tableType_t_byU16: tableType_t = 3;
pub type tableType_t = ::std::os::raw::c_int;
pub const dict_directive_noDict: dict_directive = 0;
pub const dict_directive_withPrefix64k: dict_directive = 1;
pub const dict_directive_usingExtDict: dict_directive = 2;
pub const dict_directive_usingDictCtx: dict_directive = 3;
#[doc = " This enum distinguishes several different modes of accessing previous\n content in the stream.\n\n - noDict        : There is no preceding content.\n - withPrefix64k : Table entries up to ctx->dictSize before the current blob\n                   blob being compressed are valid and refer to the preceding\n                   content (of length ctx->dictSize), which is available\n                   contiguously preceding in memory the content currently\n                   being compressed.\n - usingExtDict  : Like withPrefix64k, but the preceding content is somewhere\n                   else in memory, starting at ctx->dictionary with length\n                   ctx->dictSize.\n - usingDictCtx  : Everything concerning the preceding content is\n                   in a separate context, pointed to by ctx->dictCtx.\n                   ctx->dictionary, ctx->dictSize, and table entries\n                   in the current context that refer to positions\n                   preceding the beginning of the current compression are\n                   ignored. Instead, ctx->dictCtx->dictionary and ctx->dictCtx\n                   ->dictSize describe the location and size of the preceding\n                   content, and matches are found by looking in the ctx\n                   ->dictCtx->hashTable."]
pub type dict_directive = ::std::os::raw::c_int;
pub const dictIssue_directive_noDictIssue: dictIssue_directive = 0;
pub const dictIssue_directive_dictSmall: dictIssue_directive = 1;
pub type dictIssue_directive = ::std::os::raw::c_int;
extern "C" {
    pub fn LZ4_compress_forceExtDict(
        LZ4_dict: *mut LZ4_stream_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_safe_forceExtDict(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_void,
        dictSize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_decompress_safe_partial_forceExtDict(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        compressedSize: ::std::os::raw::c_int,
        targetOutputSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        dictStart: *const ::std::os::raw::c_void,
        dictSize: usize,
    ) -> ::std::os::raw::c_int;
}
pub const earlyEnd_directive_decode_full_block: earlyEnd_directive = 0;
pub const earlyEnd_directive_partial_decode: earlyEnd_directive = 1;
pub type earlyEnd_directive = ::std::os::raw::c_int;
extern "C" {
    pub fn read_long_length_no_check(pp: *mut *const BYTE) -> usize;
}
pub type Rvl_t = usize;
extern "C" {
    pub static rvl_error: Rvl_t;
}
extern "C" {
    #[doc = " LZ4_compress_HC() :\n  Compress data from `src` into `dst`, using the powerful but slower \"HC\" algorithm.\n `dst` must be already allocated.\n  Compression is guaranteed to succeed if `dstCapacity >= LZ4_compressBound(srcSize)` (see \"lz4.h\")\n  Max supported `srcSize` value is LZ4_MAX_INPUT_SIZE (see \"lz4.h\")\n `compressionLevel` : any value between 1 and LZ4HC_CLEVEL_MAX will work.\n                      Values > LZ4HC_CLEVEL_MAX behave the same as LZ4HC_CLEVEL_MAX.\n @return : the number of bytes written into 'dst'\n           or 0 if compression fails."]
    pub fn LZ4_compress_HC(
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC_extStateHC() :\n  Same as LZ4_compress_HC(), but using an externally allocated memory segment for `state`.\n `state` size is provided by LZ4_sizeofStateHC().\n  Memory segment must be aligned on 8-bytes boundaries (which a normal malloc() should do properly)."]
    pub fn LZ4_sizeofStateHC() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_HC_extStateHC(
        stateHC: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC_destSize() : v1.9.0+\n  Will compress as much data as possible from `src`\n  to fit into `targetDstSize` budget.\n  Result is provided in 2 parts :\n @return : the number of bytes written into 'dst' (necessarily <= targetDstSize)\n           or 0 if compression fails.\n `srcSizePtr` : on success, *srcSizePtr is updated to indicate how much bytes were read from `src`"]
    pub fn LZ4_compress_HC_destSize(
        stateHC: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSizePtr: *mut ::std::os::raw::c_int,
        targetDstSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type LZ4_streamHC_t = LZ4_streamHC_u;
extern "C" {
    #[doc = " LZ4_createStreamHC() and LZ4_freeStreamHC() :\n  These functions create and release memory for LZ4 HC streaming state.\n  Newly created states are automatically initialized.\n  A same state can be used multiple times consecutively,\n  starting with LZ4_resetStreamHC_fast() to start a new stream of blocks."]
    pub fn LZ4_createStreamHC() -> *mut LZ4_streamHC_t;
}
extern "C" {
    pub fn LZ4_freeStreamHC(streamHCPtr: *mut LZ4_streamHC_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_resetStreamHC_fast() : v1.9.0+\n  When an LZ4_streamHC_t is known to be in a internally coherent state,\n  it can often be prepared for a new compression with almost no work, only\n  sometimes falling back to the full, expensive reset that is always required\n  when the stream is in an indeterminate state (i.e., the reset performed by\n  LZ4_resetStreamHC()).\n\n  LZ4_streamHCs are guaranteed to be in a valid state when:\n  - returned from LZ4_createStreamHC()\n  - reset by LZ4_resetStreamHC()\n  - memset(stream, 0, sizeof(LZ4_streamHC_t))\n  - the stream was in a valid state and was reset by LZ4_resetStreamHC_fast()\n  - the stream was in a valid state and was then used in any compression call\n    that returned success\n  - the stream was in an indeterminate state and was used in a compression\n    call that fully reset the state (LZ4_compress_HC_extStateHC()) and that\n    returned success\n\n  Note:\n  A stream that was last used in a compression call that returned an error\n  may be passed to this function. However, it will be fully reset, which will\n  clear any existing history and settings from the context."]
    pub fn LZ4_resetStreamHC_fast(
        streamHCPtr: *mut LZ4_streamHC_t,
        compressionLevel: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn LZ4_loadDictHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        dictionary: *const ::std::os::raw::c_char,
        dictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compress_HC_continue(
        streamHCPtr: *mut LZ4_streamHC_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        maxDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_compress_HC_continue_destSize() : v1.9.0+\n  Similar to LZ4_compress_HC_continue(),\n  but will read as much data as possible from `src`\n  to fit into `targetDstSize` budget.\n  Result is provided into 2 parts :\n @return : the number of bytes written into 'dst' (necessarily <= targetDstSize)\n           or 0 if compression fails.\n `srcSizePtr` : on success, *srcSizePtr will be updated to indicate how much bytes were read from `src`.\n           Note that this function may not consume the entire input."]
    pub fn LZ4_compress_HC_continue_destSize(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSizePtr: *mut ::std::os::raw::c_int,
        targetDstSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_saveDictHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        safeBuffer: *mut ::std::os::raw::c_char,
        maxDictSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4HC_CCtx_internal {
    pub hashTable: [LZ4_u32; 32768usize],
    pub chainTable: [LZ4_u16; 65536usize],
    pub end: *const LZ4_byte,
    pub prefixStart: *const LZ4_byte,
    pub dictStart: *const LZ4_byte,
    pub dictLimit: LZ4_u32,
    pub lowLimit: LZ4_u32,
    pub nextToUpdate: LZ4_u32,
    pub compressionLevel: ::std::os::raw::c_short,
    pub favorDecSpeed: LZ4_i8,
    pub dirty: LZ4_i8,
    pub dictCtx: *const LZ4HC_CCtx_internal,
}
#[test]
fn bindgen_test_layout_LZ4HC_CCtx_internal() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4HC_CCtx_internal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4HC_CCtx_internal>(),
        262192usize,
        concat!("Size of: ", stringify!(LZ4HC_CCtx_internal))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4HC_CCtx_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4HC_CCtx_internal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hashTable) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(hashTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chainTable) as usize - ptr as usize },
        131072usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(chainTable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        262144usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefixStart) as usize - ptr as usize },
        262152usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(prefixStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictStart) as usize - ptr as usize },
        262160usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictLimit) as usize - ptr as usize },
        262168usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lowLimit) as usize - ptr as usize },
        262172usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(lowLimit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nextToUpdate) as usize - ptr as usize },
        262176usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(nextToUpdate)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compressionLevel) as usize - ptr as usize },
        262180usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(compressionLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).favorDecSpeed) as usize - ptr as usize },
        262182usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(favorDecSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dirty) as usize - ptr as usize },
        262183usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dirty)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictCtx) as usize - ptr as usize },
        262184usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_CCtx_internal),
            "::",
            stringify!(dictCtx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union LZ4_streamHC_u {
    pub minStateSize: [::std::os::raw::c_char; 262200usize],
    pub internal_donotuse: LZ4HC_CCtx_internal,
}
#[test]
fn bindgen_test_layout_LZ4_streamHC_u() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4_streamHC_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4_streamHC_u>(),
        262200usize,
        concat!("Size of: ", stringify!(LZ4_streamHC_u))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4_streamHC_u>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4_streamHC_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minStateSize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamHC_u),
            "::",
            stringify!(minStateSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).internal_donotuse) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4_streamHC_u),
            "::",
            stringify!(internal_donotuse)
        )
    );
}
extern "C" {
    pub fn LZ4_initStreamHC(
        buffer: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut LZ4_streamHC_t;
}
extern "C" {
    #[doc = "  Deprecated Functions"]
    pub fn LZ4_compressHC(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_limitedOutput(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_limitedOutput(
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_limitedOutput_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_limitedOutput_withStateHC(
        state: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_continue(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC_limitedOutput_continue(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_createHC(inputBuffer: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn LZ4_freeHC(LZ4HC_Data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_slideInputBufferHC(
        LZ4HC_Data: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn LZ4_compressHC2_continue(
        LZ4HC_Data: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_compressHC2_limitedOutput_continue(
        LZ4HC_Data: *mut ::std::os::raw::c_void,
        source: *const ::std::os::raw::c_char,
        dest: *mut ::std::os::raw::c_char,
        inputSize: ::std::os::raw::c_int,
        maxOutputSize: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_sizeofStreamStateHC() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamStateHC(
        state: *mut ::std::os::raw::c_void,
        inputBuffer: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn LZ4_resetStreamHC(
        streamHCPtr: *mut LZ4_streamHC_t,
        compressionLevel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " LZ4_setCompressionLevel() : v1.8.0+ (experimental)\n  It's possible to change compression level\n  between successive invocations of LZ4_compress_HC_continue*()\n  for dynamic adaptation."]
    pub fn LZ4_setCompressionLevel(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        compressionLevel: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " LZ4_favorDecompressionSpeed() : v1.8.2+ (experimental)\n  Opt. Parser will favor decompression speed over compression ratio.\n  Only applicable to levels >= LZ4HC_CLEVEL_OPT_MIN."]
    pub fn LZ4_favorDecompressionSpeed(
        LZ4_streamHCPtr: *mut LZ4_streamHC_t,
        favor: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = " LZ4_compress_HC_extStateHC_fastReset() :\n  A variant of LZ4_compress_HC_extStateHC().\n\n  Using this variant avoids an expensive initialization step. It is only safe\n  to call if the state buffer is known to be correctly initialized already\n  (see above comment on LZ4_resetStreamHC_fast() for a definition of\n  \"correctly initialized\"). From a high level, the difference is that this\n  function initializes the provided state with a call to\n  LZ4_resetStreamHC_fast() while LZ4_compress_HC_extStateHC() starts with a\n  call to LZ4_resetStreamHC()."]
    pub fn LZ4_compress_HC_extStateHC_fastReset(
        state: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstCapacity: ::std::os::raw::c_int,
        compressionLevel: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4_attach_HC_dictionary() :\n  This is an experimental API that allows for the efficient use of a\n  static dictionary many times.\n\n  Rather than re-loading the dictionary buffer into a working context before\n  each compression, or copying a pre-loaded dictionary's LZ4_streamHC_t into a\n  working LZ4_streamHC_t, this function introduces a no-copy setup mechanism,\n  in which the working stream references the dictionary stream in-place.\n\n  Several assumptions are made about the state of the dictionary stream.\n  Currently, only streams which have been prepared by LZ4_loadDictHC() should\n  be expected to work.\n\n  Alternatively, the provided dictionary stream pointer may be NULL, in which\n  case any existing dictionary stream is unset.\n\n  A dictionary should only be attached to a stream without any history (i.e.,\n  a stream that has just been reset).\n\n  The dictionary will remain attached to the working stream only for the\n  current stream session. Calls to LZ4_resetStreamHC(_fast) will remove the\n  dictionary context association from the working stream. The dictionary\n  stream (and source buffer) must remain in-place / accessible / unchanged\n  through the lifetime of the stream session."]
    pub fn LZ4_attach_HC_dictionary(
        working_stream: *mut LZ4_streamHC_t,
        dictionary_stream: *const LZ4_streamHC_t,
    );
}
pub const dictCtx_directive_noDictCtx: dictCtx_directive = 0;
pub const dictCtx_directive_usingDictCtxHc: dictCtx_directive = 1;
pub type dictCtx_directive = ::std::os::raw::c_int;
pub const repeat_state_e_rep_untested: repeat_state_e = 0;
pub const repeat_state_e_rep_not: repeat_state_e = 1;
pub const repeat_state_e_rep_confirmed: repeat_state_e = 2;
pub type repeat_state_e = ::std::os::raw::c_int;
pub const HCfavor_e_favorCompressionRatio: HCfavor_e = 0;
pub const HCfavor_e_favorDecompressionSpeed: HCfavor_e = 1;
pub type HCfavor_e = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4HC_optimal_t {
    pub price: ::std::os::raw::c_int,
    pub off: ::std::os::raw::c_int,
    pub mlen: ::std::os::raw::c_int,
    pub litlen: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LZ4HC_optimal_t() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4HC_optimal_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4HC_optimal_t>(),
        16usize,
        concat!("Size of: ", stringify!(LZ4HC_optimal_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4HC_optimal_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LZ4HC_optimal_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).price) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_optimal_t),
            "::",
            stringify!(price)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).off) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_optimal_t),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mlen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_optimal_t),
            "::",
            stringify!(mlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).litlen) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_optimal_t),
            "::",
            stringify!(litlen)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4HC_match_t {
    pub off: ::std::os::raw::c_int,
    pub len: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_LZ4HC_match_t() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4HC_match_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4HC_match_t>(),
        8usize,
        concat!("Size of: ", stringify!(LZ4HC_match_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4HC_match_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LZ4HC_match_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).off) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_match_t),
            "::",
            stringify!(off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4HC_match_t),
            "::",
            stringify!(len)
        )
    );
}
pub type LZ4F_errorCode_t = usize;
extern "C" {
    pub fn LZ4F_isError(code: LZ4F_errorCode_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn LZ4F_getErrorName(code: LZ4F_errorCode_t) -> *const ::std::os::raw::c_char;
}
pub const LZ4F_blockSizeID_t_LZ4F_default: LZ4F_blockSizeID_t = 0;
pub const LZ4F_blockSizeID_t_LZ4F_max64KB: LZ4F_blockSizeID_t = 4;
pub const LZ4F_blockSizeID_t_LZ4F_max256KB: LZ4F_blockSizeID_t = 5;
pub const LZ4F_blockSizeID_t_LZ4F_max1MB: LZ4F_blockSizeID_t = 6;
pub const LZ4F_blockSizeID_t_LZ4F_max4MB: LZ4F_blockSizeID_t = 7;
pub type LZ4F_blockSizeID_t = ::std::os::raw::c_int;
pub const LZ4F_blockMode_t_LZ4F_blockLinked: LZ4F_blockMode_t = 0;
pub const LZ4F_blockMode_t_LZ4F_blockIndependent: LZ4F_blockMode_t = 1;
pub type LZ4F_blockMode_t = ::std::os::raw::c_int;
pub const LZ4F_contentChecksum_t_LZ4F_noContentChecksum: LZ4F_contentChecksum_t = 0;
pub const LZ4F_contentChecksum_t_LZ4F_contentChecksumEnabled: LZ4F_contentChecksum_t = 1;
pub type LZ4F_contentChecksum_t = ::std::os::raw::c_int;
pub const LZ4F_blockChecksum_t_LZ4F_noBlockChecksum: LZ4F_blockChecksum_t = 0;
pub const LZ4F_blockChecksum_t_LZ4F_blockChecksumEnabled: LZ4F_blockChecksum_t = 1;
pub type LZ4F_blockChecksum_t = ::std::os::raw::c_int;
pub const LZ4F_frameType_t_LZ4F_frame: LZ4F_frameType_t = 0;
pub const LZ4F_frameType_t_LZ4F_skippableFrame: LZ4F_frameType_t = 1;
pub type LZ4F_frameType_t = ::std::os::raw::c_int;
#[doc = " LZ4F_frameInfo_t :\n  makes it possible to set or read frame parameters.\n  Structure must be first init to 0, using memset() or LZ4F_INIT_FRAMEINFO,\n  setting all parameters to default.\n  It's then possible to update selectively some parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_frameInfo_t {
    pub blockSizeID: LZ4F_blockSizeID_t,
    pub blockMode: LZ4F_blockMode_t,
    pub contentChecksumFlag: LZ4F_contentChecksum_t,
    pub frameType: LZ4F_frameType_t,
    pub contentSize: ::std::os::raw::c_ulonglong,
    pub dictID: ::std::os::raw::c_uint,
    pub blockChecksumFlag: LZ4F_blockChecksum_t,
}
#[test]
fn bindgen_test_layout_LZ4F_frameInfo_t() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_frameInfo_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_frameInfo_t>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4F_frameInfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_frameInfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4F_frameInfo_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockSizeID) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(blockSizeID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockMode) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(blockMode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contentChecksumFlag) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(contentChecksumFlag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameType) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(frameType)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).contentSize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(contentSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictID) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(dictID)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockChecksumFlag) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_frameInfo_t),
            "::",
            stringify!(blockChecksumFlag)
        )
    );
}
#[doc = " LZ4F_preferences_t :\n  makes it possible to supply advanced compression instructions to streaming interface.\n  Structure must be first init to 0, using memset() or LZ4F_INIT_PREFERENCES,\n  setting all parameters to default.\n  All reserved fields must be set to zero."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_preferences_t {
    pub frameInfo: LZ4F_frameInfo_t,
    pub compressionLevel: ::std::os::raw::c_int,
    pub autoFlush: ::std::os::raw::c_uint,
    pub favorDecSpeed: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_LZ4F_preferences_t() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_preferences_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_preferences_t>(),
        56usize,
        concat!("Size of: ", stringify!(LZ4F_preferences_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_preferences_t>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4F_preferences_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameInfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(frameInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).compressionLevel) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(compressionLevel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).autoFlush) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(autoFlush)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).favorDecSpeed) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(favorDecSpeed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_preferences_t),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn LZ4F_compressionLevel_max() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " LZ4F_compressFrameBound() :\n  Returns the maximum possible compressed size with LZ4F_compressFrame() given srcSize and preferences.\n `preferencesPtr` is optional. It can be replaced by NULL, in which case, the function will assume default preferences.\n  Note : this result is only usable with LZ4F_compressFrame().\n         It may also be relevant to LZ4F_compressUpdate() _only if_ no flush() operation is ever performed."]
    pub fn LZ4F_compressFrameBound(
        srcSize: usize,
        preferencesPtr: *const LZ4F_preferences_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_compressFrame() :\n  Compress an entire srcBuffer into a valid LZ4 frame.\n  dstCapacity MUST be >= LZ4F_compressFrameBound(srcSize, preferencesPtr).\n  The LZ4F_preferences_t structure is optional : you can provide NULL as argument. All preferences will be set to default.\n @return : number of bytes written into dstBuffer.\n           or an error code if it fails (can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressFrame(
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSize: usize,
        preferencesPtr: *const LZ4F_preferences_t,
    ) -> usize;
}
pub type LZ4F_cctx = LZ4F_cctx_s;
pub type LZ4F_compressionContext_t = *mut LZ4F_cctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_compressOptions_t {
    pub stableSrc: ::std::os::raw::c_uint,
    pub reserved: [::std::os::raw::c_uint; 3usize],
}
#[test]
fn bindgen_test_layout_LZ4F_compressOptions_t() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_compressOptions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_compressOptions_t>(),
        16usize,
        concat!("Size of: ", stringify!(LZ4F_compressOptions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_compressOptions_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LZ4F_compressOptions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stableSrc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_compressOptions_t),
            "::",
            stringify!(stableSrc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_compressOptions_t),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    pub fn LZ4F_getVersion() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " LZ4F_createCompressionContext() :\n  The first thing to do is to create a compressionContext object,\n  which will keep track of operation state during streaming compression.\n  This is achieved using LZ4F_createCompressionContext(), which takes as argument a version,\n  and a pointer to LZ4F_cctx*, to write the resulting pointer into.\n  @version provided MUST be LZ4F_VERSION. It is intended to track potential version mismatch, notably when using DLL.\n  The function provides a pointer to a fully allocated LZ4F_cctx object.\n  @cctxPtr MUST be != NULL.\n  If @return != zero, context creation failed.\n  A created compression context can be employed multiple times for consecutive streaming operations.\n  Once all streaming compression jobs are completed,\n  the state object can be released using LZ4F_freeCompressionContext().\n  Note1 : LZ4F_freeCompressionContext() is always successful. Its return value can be ignored.\n  Note2 : LZ4F_freeCompressionContext() works fine with NULL input pointers (do nothing)."]
    pub fn LZ4F_createCompressionContext(
        cctxPtr: *mut *mut LZ4F_cctx,
        version: ::std::os::raw::c_uint,
    ) -> LZ4F_errorCode_t;
}
extern "C" {
    pub fn LZ4F_freeCompressionContext(cctx: *mut LZ4F_cctx) -> LZ4F_errorCode_t;
}
extern "C" {
    #[doc = " LZ4F_compressBegin() :\n  will write the frame header into dstBuffer.\n  dstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes.\n `prefsPtr` is optional : you can provide NULL as argument, all preferences will then be set to default.\n @return : number of bytes written into dstBuffer for the header\n           or an error code (which can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressBegin(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        prefsPtr: *const LZ4F_preferences_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_compressBound() :\n  Provides minimum dstCapacity required to guarantee success of\n  LZ4F_compressUpdate(), given a srcSize and preferences, for a worst case scenario.\n  When srcSize==0, LZ4F_compressBound() provides an upper bound for LZ4F_flush() and LZ4F_compressEnd() instead.\n  Note that the result is only valid for a single invocation of LZ4F_compressUpdate().\n  When invoking LZ4F_compressUpdate() multiple times,\n  if the output buffer is gradually filled up instead of emptied and re-used from its start,\n  one must check if there is enough remaining capacity before each invocation, using LZ4F_compressBound().\n @return is always the same for a srcSize and prefsPtr.\n  prefsPtr is optional : when NULL is provided, preferences will be set to cover worst case scenario.\n  tech details :\n @return if automatic flushing is not enabled, includes the possibility that internal buffer might already be filled by up to (blockSize-1) bytes.\n  It also includes frame footer (ending + checksum), since it might be generated by LZ4F_compressEnd().\n @return doesn't include frame header, as it was already generated by LZ4F_compressBegin()."]
    pub fn LZ4F_compressBound(srcSize: usize, prefsPtr: *const LZ4F_preferences_t) -> usize;
}
extern "C" {
    #[doc = " LZ4F_compressUpdate() :\n  LZ4F_compressUpdate() can be called repetitively to compress as much data as necessary.\n  Important rule: dstCapacity MUST be large enough to ensure operation success even in worst case situations.\n  This value is provided by LZ4F_compressBound().\n  If this condition is not respected, LZ4F_compress() will fail (result is an errorCode).\n  After an error, the state is left in a UB state, and must be re-initialized or freed.\n  If previously an uncompressed block was written, buffered data is flushed\n  before appending compressed data is continued.\n `cOptPtr` is optional : NULL can be provided, in which case all options are set to default.\n @return : number of bytes written into `dstBuffer` (it can be zero, meaning input data was just buffered).\n           or an error code if it fails (which can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressUpdate(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSize: usize,
        cOptPtr: *const LZ4F_compressOptions_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_flush() :\n  When data must be generated and sent immediately, without waiting for a block to be completely filled,\n  it's possible to call LZ4_flush(). It will immediately compress any data buffered within cctx.\n `dstCapacity` must be large enough to ensure the operation will be successful.\n `cOptPtr` is optional : it's possible to provide NULL, all options will be set to default.\n @return : nb of bytes written into dstBuffer (can be zero, when there is no data stored within cctx)\n           or an error code if it fails (which can be tested using LZ4F_isError())\n  Note : LZ4F_flush() is guaranteed to be successful when dstCapacity >= LZ4F_compressBound(0, prefsPtr)."]
    pub fn LZ4F_flush(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        cOptPtr: *const LZ4F_compressOptions_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_compressEnd() :\n  To properly finish an LZ4 frame, invoke LZ4F_compressEnd().\n  It will flush whatever data remained within `cctx` (like LZ4_flush())\n  and properly finalize the frame, with an endMark and a checksum.\n `cOptPtr` is optional : NULL can be provided, in which case all options will be set to default.\n @return : nb of bytes written into dstBuffer, necessarily >= 4 (endMark),\n           or an error code if it fails (which can be tested using LZ4F_isError())\n  Note : LZ4F_compressEnd() is guaranteed to be successful when dstCapacity >= LZ4F_compressBound(0, prefsPtr).\n  A successful call to LZ4F_compressEnd() makes `cctx` available again for another compression task."]
    pub fn LZ4F_compressEnd(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        cOptPtr: *const LZ4F_compressOptions_t,
    ) -> usize;
}
pub type LZ4F_dctx = LZ4F_dctx_s;
pub type LZ4F_decompressionContext_t = *mut LZ4F_dctx;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_decompressOptions_t {
    pub stableDst: ::std::os::raw::c_uint,
    pub skipChecksums: ::std::os::raw::c_uint,
    pub reserved1: ::std::os::raw::c_uint,
    pub reserved0: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_LZ4F_decompressOptions_t() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_decompressOptions_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_decompressOptions_t>(),
        16usize,
        concat!("Size of: ", stringify!(LZ4F_decompressOptions_t))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_decompressOptions_t>(),
        4usize,
        concat!("Alignment of ", stringify!(LZ4F_decompressOptions_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stableDst) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_decompressOptions_t),
            "::",
            stringify!(stableDst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skipChecksums) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_decompressOptions_t),
            "::",
            stringify!(skipChecksums)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_decompressOptions_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_decompressOptions_t),
            "::",
            stringify!(reserved0)
        )
    );
}
extern "C" {
    #[doc = " LZ4F_createDecompressionContext() :\n  Create an LZ4F_dctx object, to track all decompression operations.\n  @version provided MUST be LZ4F_VERSION.\n  @dctxPtr MUST be valid.\n  The function fills @dctxPtr with the value of a pointer to an allocated and initialized LZ4F_dctx object.\n  The @return is an errorCode, which can be tested using LZ4F_isError().\n  dctx memory can be released using LZ4F_freeDecompressionContext();\n  Result of LZ4F_freeDecompressionContext() indicates current state of decompressionContext when being released.\n  That is, it should be == 0 if decompression has been completed fully and correctly."]
    pub fn LZ4F_createDecompressionContext(
        dctxPtr: *mut *mut LZ4F_dctx,
        version: ::std::os::raw::c_uint,
    ) -> LZ4F_errorCode_t;
}
extern "C" {
    pub fn LZ4F_freeDecompressionContext(dctx: *mut LZ4F_dctx) -> LZ4F_errorCode_t;
}
extern "C" {
    #[doc = " LZ4F_headerSize() : v1.9.0+\n  Provide the header size of a frame starting at `src`.\n `srcSize` must be >= LZ4F_MIN_SIZE_TO_KNOW_HEADER_LENGTH,\n  which is enough to decode the header length.\n @return : size of frame header\n           or an error code, which can be tested using LZ4F_isError()\n  note : Frame header size is variable, but is guaranteed to be\n         >= LZ4F_HEADER_SIZE_MIN bytes, and <= LZ4F_HEADER_SIZE_MAX bytes."]
    pub fn LZ4F_headerSize(src: *const ::std::os::raw::c_void, srcSize: usize) -> usize;
}
extern "C" {
    #[doc = " LZ4F_getFrameInfo() :\n  This function extracts frame parameters (max blockSize, dictID, etc.).\n  Its usage is optional: user can also invoke LZ4F_decompress() directly.\n\n  Extracted information will fill an existing LZ4F_frameInfo_t structure.\n  This can be useful for allocation and dictionary identification purposes.\n\n  LZ4F_getFrameInfo() can work in the following situations :\n\n  1) At the beginning of a new frame, before any invocation of LZ4F_decompress().\n     It will decode header from `srcBuffer`,\n     consuming the header and starting the decoding process.\n\n     Input size must be large enough to contain the full frame header.\n     Frame header size can be known beforehand by LZ4F_headerSize().\n     Frame header size is variable, but is guaranteed to be >= LZ4F_HEADER_SIZE_MIN bytes,\n     and not more than <= LZ4F_HEADER_SIZE_MAX bytes.\n     Hence, blindly providing LZ4F_HEADER_SIZE_MAX bytes or more will always work.\n     It's allowed to provide more input data than the header size,\n     LZ4F_getFrameInfo() will only consume the header.\n\n     If input size is not large enough,\n     aka if it's smaller than header size,\n     function will fail and return an error code.\n\n  2) After decoding has been started,\n     it's possible to invoke LZ4F_getFrameInfo() anytime\n     to extract already decoded frame parameters stored within dctx.\n\n     Note that, if decoding has barely started,\n     and not yet read enough information to decode the header,\n     LZ4F_getFrameInfo() will fail.\n\n  The number of bytes consumed from srcBuffer will be updated in *srcSizePtr (necessarily <= original value).\n  LZ4F_getFrameInfo() only consumes bytes when decoding has not yet started,\n  and when decoding the header has been successful.\n  Decompression must then resume from (srcBuffer + *srcSizePtr).\n\n @return : a hint about how many srcSize bytes LZ4F_decompress() expects for next call,\n           or an error code which can be tested using LZ4F_isError().\n  note 1 : in case of error, dctx is not modified. Decoding operation can resume from beginning safely.\n  note 2 : frame parameters are *copied into* an already allocated LZ4F_frameInfo_t structure."]
    pub fn LZ4F_getFrameInfo(
        dctx: *mut LZ4F_dctx,
        frameInfoPtr: *mut LZ4F_frameInfo_t,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSizePtr: *mut usize,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_decompress() :\n  Call this function repetitively to regenerate data compressed in `srcBuffer`.\n\n  The function requires a valid dctx state.\n  It will read up to *srcSizePtr bytes from srcBuffer,\n  and decompress data into dstBuffer, of capacity *dstSizePtr.\n\n  The nb of bytes consumed from srcBuffer will be written into *srcSizePtr (necessarily <= original value).\n  The nb of bytes decompressed into dstBuffer will be written into *dstSizePtr (necessarily <= original value).\n\n  The function does not necessarily read all input bytes, so always check value in *srcSizePtr.\n  Unconsumed source data must be presented again in subsequent invocations.\n\n `dstBuffer` can freely change between each consecutive function invocation.\n `dstBuffer` content will be overwritten.\n\n @return : an hint of how many `srcSize` bytes LZ4F_decompress() expects for next call.\n  Schematically, it's the size of the current (or remaining) compressed block + header of next block.\n  Respecting the hint provides some small speed benefit, because it skips intermediate buffers.\n  This is just a hint though, it's always possible to provide any srcSize.\n\n  When a frame is fully decoded, @return will be 0 (no more data expected).\n  When provided with more bytes than necessary to decode a frame,\n  LZ4F_decompress() will stop reading exactly at end of current frame, and @return 0.\n\n  If decompression failed, @return is an error code, which can be tested using LZ4F_isError().\n  After a decompression error, the `dctx` context is not resumable.\n  Use LZ4F_resetDecompressionContext() to return to clean state.\n\n  After a frame is fully decoded, dctx can be used again to decompress another frame."]
    pub fn LZ4F_decompress(
        dctx: *mut LZ4F_dctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstSizePtr: *mut usize,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSizePtr: *mut usize,
        dOptPtr: *const LZ4F_decompressOptions_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_resetDecompressionContext() : added in v1.8.0\n  In case of an error, the context is left in \"undefined\" state.\n  In which case, it's necessary to reset it, before re-using it.\n  This method can also be used to abruptly stop any unfinished decompression,\n  and start a new one using same context resources."]
    pub fn LZ4F_resetDecompressionContext(dctx: *mut LZ4F_dctx);
}
pub const LZ4F_errorCodes_LZ4F_OK_NoError: LZ4F_errorCodes = 0;
pub const LZ4F_errorCodes_LZ4F_ERROR_GENERIC: LZ4F_errorCodes = 1;
pub const LZ4F_errorCodes_LZ4F_ERROR_maxBlockSize_invalid: LZ4F_errorCodes = 2;
pub const LZ4F_errorCodes_LZ4F_ERROR_blockMode_invalid: LZ4F_errorCodes = 3;
pub const LZ4F_errorCodes_LZ4F_ERROR_contentChecksumFlag_invalid: LZ4F_errorCodes = 4;
pub const LZ4F_errorCodes_LZ4F_ERROR_compressionLevel_invalid: LZ4F_errorCodes = 5;
pub const LZ4F_errorCodes_LZ4F_ERROR_headerVersion_wrong: LZ4F_errorCodes = 6;
pub const LZ4F_errorCodes_LZ4F_ERROR_blockChecksum_invalid: LZ4F_errorCodes = 7;
pub const LZ4F_errorCodes_LZ4F_ERROR_reservedFlag_set: LZ4F_errorCodes = 8;
pub const LZ4F_errorCodes_LZ4F_ERROR_allocation_failed: LZ4F_errorCodes = 9;
pub const LZ4F_errorCodes_LZ4F_ERROR_srcSize_tooLarge: LZ4F_errorCodes = 10;
pub const LZ4F_errorCodes_LZ4F_ERROR_dstMaxSize_tooSmall: LZ4F_errorCodes = 11;
pub const LZ4F_errorCodes_LZ4F_ERROR_frameHeader_incomplete: LZ4F_errorCodes = 12;
pub const LZ4F_errorCodes_LZ4F_ERROR_frameType_unknown: LZ4F_errorCodes = 13;
pub const LZ4F_errorCodes_LZ4F_ERROR_frameSize_wrong: LZ4F_errorCodes = 14;
pub const LZ4F_errorCodes_LZ4F_ERROR_srcPtr_wrong: LZ4F_errorCodes = 15;
pub const LZ4F_errorCodes_LZ4F_ERROR_decompressionFailed: LZ4F_errorCodes = 16;
pub const LZ4F_errorCodes_LZ4F_ERROR_headerChecksum_invalid: LZ4F_errorCodes = 17;
pub const LZ4F_errorCodes_LZ4F_ERROR_contentChecksum_invalid: LZ4F_errorCodes = 18;
pub const LZ4F_errorCodes_LZ4F_ERROR_frameDecoding_alreadyStarted: LZ4F_errorCodes = 19;
pub const LZ4F_errorCodes_LZ4F_ERROR_compressionState_uninitialized: LZ4F_errorCodes = 20;
pub const LZ4F_errorCodes_LZ4F_ERROR_parameter_null: LZ4F_errorCodes = 21;
pub const LZ4F_errorCodes_LZ4F_ERROR_maxCode: LZ4F_errorCodes = 22;
pub const LZ4F_errorCodes__LZ4F_dummy_error_enum_for_c89_never_used: LZ4F_errorCodes = 23;
pub type LZ4F_errorCodes = ::std::os::raw::c_int;
extern "C" {
    pub fn LZ4F_getErrorCode(functionResult: usize) -> LZ4F_errorCodes;
}
extern "C" {
    #[doc = " LZ4F_getBlockSize() :\n  Return, in scalar format (size_t),\n  the maximum block size associated with blockSizeID."]
    pub fn LZ4F_getBlockSize(blockSizeID: LZ4F_blockSizeID_t) -> usize;
}
extern "C" {
    #[doc = " LZ4F_uncompressedUpdate() :\n  LZ4F_uncompressedUpdate() can be called repetitively to add as much data uncompressed data as necessary.\n  Important rule: dstCapacity MUST be large enough to store the entire source buffer as\n  no compression is done for this operation\n  If this condition is not respected, LZ4F_uncompressedUpdate() will fail (result is an errorCode).\n  After an error, the state is left in a UB state, and must be re-initialized or freed.\n  If previously a compressed block was written, buffered data is flushed\n  before appending uncompressed data is continued.\n  This is only supported when LZ4F_blockIndependent is used\n `cOptPtr` is optional : NULL can be provided, in which case all options are set to default.\n @return : number of bytes written into `dstBuffer` (it can be zero, meaning input data was just buffered).\n           or an error code if it fails (which can be tested using LZ4F_isError())"]
    pub fn LZ4F_uncompressedUpdate(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSize: usize,
        cOptPtr: *const LZ4F_compressOptions_t,
    ) -> usize;
}
#[doc = "  Bulk processing dictionary API"]
pub type LZ4F_CDict = LZ4F_CDict_s;
extern "C" {
    #[doc = " LZ4_createCDict() :\n  When compressing multiple messages / blocks using the same dictionary, it's recommended to load it just once.\n  LZ4_createCDict() will create a digested dictionary, ready to start future compression operations without startup delay.\n  LZ4_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only.\n `dictBuffer` can be released after LZ4_CDict creation, since its content is copied within CDict"]
    pub fn LZ4F_createCDict(
        dictBuffer: *const ::std::os::raw::c_void,
        dictSize: usize,
    ) -> *mut LZ4F_CDict;
}
extern "C" {
    pub fn LZ4F_freeCDict(CDict: *mut LZ4F_CDict);
}
extern "C" {
    #[doc = " LZ4_compressFrame_usingCDict() :\n  Compress an entire srcBuffer into a valid LZ4 frame using a digested Dictionary.\n  cctx must point to a context created by LZ4F_createCompressionContext().\n  If cdict==NULL, compress without a dictionary.\n  dstBuffer MUST be >= LZ4F_compressFrameBound(srcSize, preferencesPtr).\n  If this condition is not respected, function will fail (@return an errorCode).\n  The LZ4F_preferences_t structure is optional : you may provide NULL as argument,\n  but it's not recommended, as it's the only way to provide dictID in the frame header.\n @return : number of bytes written into dstBuffer.\n           or an error code if it fails (can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressFrame_usingCDict(
        cctx: *mut LZ4F_cctx,
        dst: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        src: *const ::std::os::raw::c_void,
        srcSize: usize,
        cdict: *const LZ4F_CDict,
        preferencesPtr: *const LZ4F_preferences_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_compressBegin_usingCDict() :\n  Inits streaming dictionary compression, and writes the frame header into dstBuffer.\n  dstCapacity must be >= LZ4F_HEADER_SIZE_MAX bytes.\n `prefsPtr` is optional : you may provide NULL as argument,\n  however, it's the only way to provide dictID in the frame header.\n @return : number of bytes written into dstBuffer for the header,\n           or an error code (which can be tested using LZ4F_isError())"]
    pub fn LZ4F_compressBegin_usingCDict(
        cctx: *mut LZ4F_cctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstCapacity: usize,
        cdict: *const LZ4F_CDict,
        prefsPtr: *const LZ4F_preferences_t,
    ) -> usize;
}
extern "C" {
    #[doc = " LZ4F_decompress_usingDict() :\n  Same as LZ4F_decompress(), using a predefined dictionary.\n  Dictionary is used \"in place\", without any preprocessing.\n  It must remain accessible throughout the entire frame decoding."]
    pub fn LZ4F_decompress_usingDict(
        dctxPtr: *mut LZ4F_dctx,
        dstBuffer: *mut ::std::os::raw::c_void,
        dstSizePtr: *mut usize,
        srcBuffer: *const ::std::os::raw::c_void,
        srcSizePtr: *mut usize,
        dict: *const ::std::os::raw::c_void,
        dictSize: usize,
        decompressOptionsPtr: *const LZ4F_decompressOptions_t,
    ) -> usize;
}
#[doc = " Custom memory allocation :\n  These prototypes make it possible to pass custom allocation/free functions.\n  LZ4F_customMem is provided at state creation time, using LZ4F_create*_advanced() listed below.\n  All allocation/free operations will be completed using these custom variants instead of regular <stdlib.h> ones."]
pub type LZ4F_AllocFunction = ::std::option::Option<
    unsafe extern "C" fn(
        opaqueState: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type LZ4F_CallocFunction = ::std::option::Option<
    unsafe extern "C" fn(
        opaqueState: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type LZ4F_FreeFunction = ::std::option::Option<
    unsafe extern "C" fn(
        opaqueState: *mut ::std::os::raw::c_void,
        address: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_CustomMem {
    pub customAlloc: LZ4F_AllocFunction,
    pub customCalloc: LZ4F_CallocFunction,
    pub customFree: LZ4F_FreeFunction,
    pub opaqueState: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_LZ4F_CustomMem() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_CustomMem> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_CustomMem>(),
        32usize,
        concat!("Size of: ", stringify!(LZ4F_CustomMem))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_CustomMem>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4F_CustomMem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customAlloc) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_CustomMem),
            "::",
            stringify!(customAlloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customCalloc) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_CustomMem),
            "::",
            stringify!(customCalloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).customFree) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_CustomMem),
            "::",
            stringify!(customFree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opaqueState) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_CustomMem),
            "::",
            stringify!(opaqueState)
        )
    );
}
extern "C" {
    #[doc = "< this constant defers to stdlib's functions"]
    pub static LZ4F_defaultCMem: LZ4F_CustomMem;
}
extern "C" {
    pub fn LZ4F_createCompressionContext_advanced(
        customMem: LZ4F_CustomMem,
        version: ::std::os::raw::c_uint,
    ) -> *mut LZ4F_cctx;
}
extern "C" {
    pub fn LZ4F_createDecompressionContext_advanced(
        customMem: LZ4F_CustomMem,
        version: ::std::os::raw::c_uint,
    ) -> *mut LZ4F_dctx;
}
extern "C" {
    pub fn LZ4F_createCDict_advanced(
        customMem: LZ4F_CustomMem,
        dictBuffer: *const ::std::os::raw::c_void,
        dictSize: usize,
    ) -> *mut LZ4F_CDict;
}
pub const XXH_errorcode_XXH_OK: XXH_errorcode = 0;
pub const XXH_errorcode_XXH_ERROR: XXH_errorcode = 1;
pub type XXH_errorcode = ::std::os::raw::c_int;
extern "C" {
    pub fn XXH_versionNumber() -> ::std::os::raw::c_uint;
}
pub type XXH32_hash_t = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " XXH32() :\nCalculate the 32-bit hash of sequence \"length\" bytes stored at memory address \"input\".\nThe memory between input & input+length must be valid (allocated and read-accessible).\n\"seed\" can be used to alter the result predictably.\nSpeed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s"]
    pub fn XXH32(
        input: *const ::std::os::raw::c_void,
        length: usize,
        seed: ::std::os::raw::c_uint,
    ) -> XXH32_hash_t;
}
pub type XXH32_state_t = XXH32_state_s;
extern "C" {
    pub fn XXH32_createState() -> *mut XXH32_state_t;
}
extern "C" {
    pub fn XXH32_freeState(statePtr: *mut XXH32_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH32_copyState(dst_state: *mut XXH32_state_t, src_state: *const XXH32_state_t);
}
extern "C" {
    pub fn XXH32_reset(statePtr: *mut XXH32_state_t, seed: ::std::os::raw::c_uint)
        -> XXH_errorcode;
}
extern "C" {
    pub fn XXH32_update(
        statePtr: *mut XXH32_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH32_digest(statePtr: *const XXH32_state_t) -> XXH32_hash_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH32_canonical_t {
    pub digest: [::std::os::raw::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout_XXH32_canonical_t() {
    const UNINIT: ::std::mem::MaybeUninit<XXH32_canonical_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XXH32_canonical_t>(),
        4usize,
        concat!("Size of: ", stringify!(XXH32_canonical_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH32_canonical_t>(),
        1usize,
        concat!("Alignment of ", stringify!(XXH32_canonical_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_canonical_t),
            "::",
            stringify!(digest)
        )
    );
}
extern "C" {
    #[doc = " Default XXH result types are basic unsigned 32 and 64 bits.\n   The canonical representation follows human-readable write convention, aka big-endian (large digits first).\n   These functions allow transformation of hash result into and from its canonical format.\n   This way, hash values can be written into a file or buffer, remaining comparable across different systems."]
    pub fn XXH32_canonicalFromHash(dst: *mut XXH32_canonical_t, hash: XXH32_hash_t);
}
extern "C" {
    pub fn XXH32_hashFromCanonical(src: *const XXH32_canonical_t) -> XXH32_hash_t;
}
pub type XXH64_hash_t = ::std::os::raw::c_ulonglong;
extern "C" {
    #[doc = " XXH64() :\nCalculate the 64-bit hash of sequence of length \"len\" stored at memory address \"input\".\n\"seed\" can be used to alter the result predictably.\nThis function runs faster on 64-bit systems, but slower on 32-bit systems (see benchmark)."]
    pub fn XXH64(
        input: *const ::std::os::raw::c_void,
        length: usize,
        seed: ::std::os::raw::c_ulonglong,
    ) -> XXH64_hash_t;
}
pub type XXH64_state_t = XXH64_state_s;
extern "C" {
    pub fn XXH64_createState() -> *mut XXH64_state_t;
}
extern "C" {
    pub fn XXH64_freeState(statePtr: *mut XXH64_state_t) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_copyState(dst_state: *mut XXH64_state_t, src_state: *const XXH64_state_t);
}
extern "C" {
    pub fn XXH64_reset(
        statePtr: *mut XXH64_state_t,
        seed: ::std::os::raw::c_ulonglong,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_update(
        statePtr: *mut XXH64_state_t,
        input: *const ::std::os::raw::c_void,
        length: usize,
    ) -> XXH_errorcode;
}
extern "C" {
    pub fn XXH64_digest(statePtr: *const XXH64_state_t) -> XXH64_hash_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH64_canonical_t {
    pub digest: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_XXH64_canonical_t() {
    const UNINIT: ::std::mem::MaybeUninit<XXH64_canonical_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XXH64_canonical_t>(),
        8usize,
        concat!("Size of: ", stringify!(XXH64_canonical_t))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH64_canonical_t>(),
        1usize,
        concat!("Alignment of ", stringify!(XXH64_canonical_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).digest) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_canonical_t),
            "::",
            stringify!(digest)
        )
    );
}
extern "C" {
    pub fn XXH64_canonicalFromHash(dst: *mut XXH64_canonical_t, hash: XXH64_hash_t);
}
extern "C" {
    pub fn XXH64_hashFromCanonical(src: *const XXH64_canonical_t) -> XXH64_hash_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH32_state_s {
    pub total_len_32: u32,
    pub large_len: u32,
    pub v1: u32,
    pub v2: u32,
    pub v3: u32,
    pub v4: u32,
    pub mem32: [u32; 4usize],
    pub memsize: u32,
    pub reserved: u32,
}
#[test]
fn bindgen_test_layout_XXH32_state_s() {
    const UNINIT: ::std::mem::MaybeUninit<XXH32_state_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XXH32_state_s>(),
        48usize,
        concat!("Size of: ", stringify!(XXH32_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH32_state_s>(),
        4usize,
        concat!("Alignment of ", stringify!(XXH32_state_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_len_32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(total_len_32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).large_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(large_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v2) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(v2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(v3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(v4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem32) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(mem32)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(memsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH32_state_s),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct XXH64_state_s {
    pub total_len: u64,
    pub v1: u64,
    pub v2: u64,
    pub v3: u64,
    pub v4: u64,
    pub mem64: [u64; 4usize],
    pub memsize: u32,
    pub reserved: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_XXH64_state_s() {
    const UNINIT: ::std::mem::MaybeUninit<XXH64_state_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<XXH64_state_s>(),
        88usize,
        concat!("Size of: ", stringify!(XXH64_state_s))
    );
    assert_eq!(
        ::std::mem::align_of::<XXH64_state_s>(),
        8usize,
        concat!("Alignment of ", stringify!(XXH64_state_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).total_len) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(total_len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(v1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(v2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v3) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(v3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v4) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(v4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mem64) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(mem64)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).memsize) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(memsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(XXH64_state_s),
            "::",
            stringify!(reserved)
        )
    );
}
pub const minFHSize: usize = 7;
pub const maxFHSize: usize = 19;
pub const BHSize: usize = 4;
pub const BFSize: usize = 4;
pub const LZ4F_blockCompression_t_LZ4B_COMPRESSED: LZ4F_blockCompression_t = 0;
pub const LZ4F_blockCompression_t_LZ4B_UNCOMPRESSED: LZ4F_blockCompression_t = 1;
pub type LZ4F_blockCompression_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_cctx_s {
    pub cmem: LZ4F_CustomMem,
    pub prefs: LZ4F_preferences_t,
    pub version: U32,
    pub cStage: U32,
    pub cdict: *const LZ4F_CDict,
    pub maxBlockSize: usize,
    pub maxBufferSize: usize,
    pub tmpBuff: *mut BYTE,
    pub tmpIn: *mut BYTE,
    pub tmpInSize: usize,
    pub totalInSize: U64,
    pub xxh: XXH32_state_t,
    pub lz4CtxPtr: *mut ::std::os::raw::c_void,
    pub lz4CtxAlloc: U16,
    pub lz4CtxState: U16,
    pub blockCompression: LZ4F_blockCompression_t,
}
#[test]
fn bindgen_test_layout_LZ4F_cctx_s() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_cctx_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_cctx_s>(),
        216usize,
        concat!("Size of: ", stringify!(LZ4F_cctx_s))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_cctx_s>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4F_cctx_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(cmem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).prefs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(prefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cStage) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(cStage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdict) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(cdict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBlockSize) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(maxBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBufferSize) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(maxBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmpBuff) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(tmpBuff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmpIn) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(tmpIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmpInSize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(tmpInSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalInSize) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(totalInSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xxh) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(xxh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lz4CtxPtr) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(lz4CtxPtr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lz4CtxAlloc) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(lz4CtxAlloc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lz4CtxState) as usize - ptr as usize },
        210usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(lz4CtxState)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockCompression) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_cctx_s),
            "::",
            stringify!(blockCompression)
        )
    );
}
pub type LZ4F_cctx_t = LZ4F_cctx_s;
extern "C" {
    pub static mut LZ4F_errorStrings: [*const ::std::os::raw::c_char; 23usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_CDict_s {
    pub cmem: LZ4F_CustomMem,
    pub dictContent: *mut ::std::os::raw::c_void,
    pub fastCtx: *mut LZ4_stream_t,
    pub HCCtx: *mut LZ4_streamHC_t,
}
#[test]
fn bindgen_test_layout_LZ4F_CDict_s() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_CDict_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_CDict_s>(),
        56usize,
        concat!("Size of: ", stringify!(LZ4F_CDict_s))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_CDict_s>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4F_CDict_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_CDict_s),
            "::",
            stringify!(cmem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictContent) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_CDict_s),
            "::",
            stringify!(dictContent)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fastCtx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_CDict_s),
            "::",
            stringify!(fastCtx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).HCCtx) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_CDict_s),
            "::",
            stringify!(HCCtx)
        )
    );
}
pub type compressFunc_t = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut ::std::os::raw::c_void,
        src: *const ::std::os::raw::c_char,
        dst: *mut ::std::os::raw::c_char,
        srcSize: ::std::os::raw::c_int,
        dstSize: ::std::os::raw::c_int,
        level: ::std::os::raw::c_int,
        cdict: *const LZ4F_CDict,
    ) -> ::std::os::raw::c_int,
>;
pub const LZ4F_lastBlockStatus_notDone: LZ4F_lastBlockStatus = 0;
pub const LZ4F_lastBlockStatus_fromTmpBuffer: LZ4F_lastBlockStatus = 1;
pub const LZ4F_lastBlockStatus_fromSrcBuffer: LZ4F_lastBlockStatus = 2;
pub type LZ4F_lastBlockStatus = ::std::os::raw::c_int;
extern "C" {
    pub static k_cOptionsNull: LZ4F_compressOptions_t;
}
pub const dStage_t_dstage_getFrameHeader: dStage_t = 0;
pub const dStage_t_dstage_storeFrameHeader: dStage_t = 1;
pub const dStage_t_dstage_init: dStage_t = 2;
pub const dStage_t_dstage_getBlockHeader: dStage_t = 3;
pub const dStage_t_dstage_storeBlockHeader: dStage_t = 4;
pub const dStage_t_dstage_copyDirect: dStage_t = 5;
pub const dStage_t_dstage_getBlockChecksum: dStage_t = 6;
pub const dStage_t_dstage_getCBlock: dStage_t = 7;
pub const dStage_t_dstage_storeCBlock: dStage_t = 8;
pub const dStage_t_dstage_flushOut: dStage_t = 9;
pub const dStage_t_dstage_getSuffix: dStage_t = 10;
pub const dStage_t_dstage_storeSuffix: dStage_t = 11;
pub const dStage_t_dstage_getSFrameSize: dStage_t = 12;
pub const dStage_t_dstage_storeSFrameSize: dStage_t = 13;
pub const dStage_t_dstage_skipSkippable: dStage_t = 14;
pub type dStage_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LZ4F_dctx_s {
    pub cmem: LZ4F_CustomMem,
    pub frameInfo: LZ4F_frameInfo_t,
    pub version: U32,
    pub dStage: dStage_t,
    pub frameRemainingSize: U64,
    pub maxBlockSize: usize,
    pub maxBufferSize: usize,
    pub tmpIn: *mut BYTE,
    pub tmpInSize: usize,
    pub tmpInTarget: usize,
    pub tmpOutBuffer: *mut BYTE,
    pub dict: *const BYTE,
    pub dictSize: usize,
    pub tmpOut: *mut BYTE,
    pub tmpOutSize: usize,
    pub tmpOutStart: usize,
    pub xxh: XXH32_state_t,
    pub blockChecksum: XXH32_state_t,
    pub skipChecksum: ::std::os::raw::c_int,
    pub header: [BYTE; 19usize],
}
#[test]
fn bindgen_test_layout_LZ4F_dctx_s() {
    const UNINIT: ::std::mem::MaybeUninit<LZ4F_dctx_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LZ4F_dctx_s>(),
        288usize,
        concat!("Size of: ", stringify!(LZ4F_dctx_s))
    );
    assert_eq!(
        ::std::mem::align_of::<LZ4F_dctx_s>(),
        8usize,
        concat!("Alignment of ", stringify!(LZ4F_dctx_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cmem) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(cmem)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameInfo) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(frameInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dStage) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(dStage)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frameRemainingSize) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(frameRemainingSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBlockSize) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(maxBlockSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxBufferSize) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(maxBufferSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmpIn) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(tmpIn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmpInSize) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(tmpInSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmpInTarget) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(tmpInTarget)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmpOutBuffer) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(tmpOutBuffer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dict) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(dict)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dictSize) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(dictSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmpOut) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(tmpOut)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmpOutSize) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(tmpOutSize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tmpOutStart) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(tmpOutStart)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xxh) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(xxh)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).blockChecksum) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(blockChecksum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skipChecksum) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(skipChecksum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(LZ4F_dctx_s),
            "::",
            stringify!(header)
        )
    );
}
extern "C" {
    pub fn _wassert(_Message: *const wchar_t, _File: *const wchar_t, _Line: ::std::os::raw::c_uint);
}
pub const XXH_endianess_XXH_bigEndian: XXH_endianess = 0;
pub const XXH_endianess_XXH_littleEndian: XXH_endianess = 1;
pub type XXH_endianess = ::std::os::raw::c_int;
pub const XXH_alignment_XXH_aligned: XXH_alignment = 0;
pub const XXH_alignment_XXH_unaligned: XXH_alignment = 1;
pub type XXH_alignment = ::std::os::raw::c_int;
pub const PRIME32_1: U32 = 2654435761;
pub const PRIME32_2: U32 = 2246822519;
pub const PRIME32_3: U32 = 3266489917;
pub const PRIME32_4: U32 = 668265263;
pub const PRIME32_5: U32 = 374761393;
pub const PRIME64_1: U64 = 11400714785074694791;
pub const PRIME64_2: U64 = 14029467366897019727;
pub const PRIME64_3: U64 = 1609587929392839161;
pub const PRIME64_4: U64 = 9650029242287828579;
pub const PRIME64_5: U64 = 2870177450012600261;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
